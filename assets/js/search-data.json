{
  
    
        "post0": {
            "title": "Create your custom Path class",
            "content": "This is the fourth of a series of posts whose aim is to go through the complete development of fastcore and fastai2. . Recap: patching an existing class (adding a function to it) . Here we do a recap of a functionality covered in this post . First, we need a way to properly copy a function. i.e. create an exact replica of a given function. . def copy_func(f): &quot;Copy a non-builtin function (NB `copy.copy` does not work for this)&quot; if not isinstance(f,FunctionType): return copy(f) fn = FunctionType(f.__code__, f.__globals__, f.__name__, f.__defaults__, f.__closure__) fn.__dict__.update(f.__dict__) return fn . Here we copy the function for each class in cls, and we also copy its attributes in functools.WRAPPER_ASSIGNMENTS, i.e., (&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;). __qualname__ needs to be updated to match its new location as a method (or property depending on as_prop) in the class beiing considered. . def patch_to(cls, as_prop=False): &quot;Decorator: add `f` to `cls`&quot; if not isinstance(cls, (tuple,list)): cls=(cls,) def _inner(f): for c_ in cls: nf = copy_func(f) for o in functools.WRAPPER_ASSIGNMENTS: setattr(nf, o, getattr(f,o)) nf.__qualname__ = f&quot;{c_.__name__}.{f.__name__}&quot; setattr(c_, f.__name__, property(nf) if as_prop else nf) return f return _inner . Same as above, but infers the class by the first type annotation of f. . def patch(f): &quot;Decorator: add `f` to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls)(f) . Now that we have a decorator to start patching classes, let&#39;s go ahead and add some methods to Path. . @patch def readlines(self:Path, hint=-1, encoding=&#39;utf8&#39;): &quot;Read the content of `fname`&quot; with self.open(encoding=encoding) as f: return f.readlines(hint) . @patch def read(self:Path, size=-1, encoding=&#39;utf8&#39;): &quot;Read the content of `fname`&quot; with self.open(encoding=encoding) as f: return f.read(size) . @patch def write(self:Path, txt, encoding=&#39;utf8&#39;): &quot;Write `txt` to `self`, creating directories as needed&quot; self.parent.mkdir(parents=True,exist_ok=True) with self.open(&#39;w&#39;, encoding=encoding) as f: f.write(txt) . with tempfile.NamedTemporaryFile() as f: fn = Path(f.name) fn.write(&#39;t&#39;) t = fn.read() test_eq(t,&#39;t&#39;) t = fn.readlines() test_eq(t,[&#39;t&#39;]) . @patch def save(fn:Path, o): &quot;Save a pickle file, to a file name or opened file&quot; if not isinstance(fn, io.IOBase): fn = open(fn,&#39;wb&#39;) try: pickle.dump(o, fn) finally: fn.close() . @patch def load(fn:Path): &quot;Load a pickle file from a file name or opened file&quot; if not isinstance(fn, io.IOBase): fn = open(fn,&#39;rb&#39;) try: return pickle.load(fn) finally: fn.close() . with tempfile.NamedTemporaryFile() as f: fn = Path(f.name) fn.save(&#39;t&#39;) t = fn.load() test_eq(t,&#39;t&#39;) . L was covered in this post and can be imported with from fastcore.utils import L . @patch def ls(self:Path, n_max=None, file_type=None, file_exts=None): &quot;Contents of path as a list&quot; extns=L(file_exts) if file_type: extns += L(k for k,v in mimetypes.types_map.items() if v.startswith(file_type+&#39;/&#39;)) has_extns = len(extns)==0 res = (o for o in self.iterdir() if has_extns or o.suffix in extns) if n_max is not None: res = itertools.islice(res, n_max) return L(res) . We add an ls() method to pathlib.Path which is simply defined as list(Path.iterdir()), mainly for convenience in REPL environments such as notebooks. . path = Path() t = path.ls() assert len(t)&gt;0 t1 = path.ls(10) test_eq(len(t1), 10) t2 = path.ls(file_exts=&#39;.ipynb&#39;) assert len(t)&gt;len(t2) t[0] . Path(&#39;02_utils.ipynb&#39;) . You can also pass an optional file_type MIME prefix and/or a list of file extensions. . img_path = (path/&#39;my_icons&#39;) img_files=img_path.ls(file_type=&#39;image&#39;) assert len(img_files) &gt; 0 and img_files[0].suffix==&#39;.gif&#39; ipy_files=path.ls(file_exts=[&#39;.ipynb&#39;]) assert len(ipy_files) &gt; 0 and ipy_files[0].suffix==&#39;.ipynb&#39; img_files[0],ipy_files[0] . (Path(&#39;my_icons/atom.gif&#39;), Path(&#39;02_utils.ipynb&#39;)) . pkl = pickle.dumps(path) p2 =pickle.loads(pkl) test_eq(path.ls()[0], p2.ls()[0]) . @patch def __repr__(self:Path): b = getattr(Path, &#39;BASE_PATH&#39;, None) if b: try: self = self.relative_to(b) except: pass return f&quot;Path({self.as_posix()!r})&quot; . fastai also updates the repr of Path such that, if Path.BASE_PATH is defined, all paths are printed relative to that path (as long as they are contained in Path.BASE_PATH: . t = ipy_files[0].absolute() try: Path.BASE_PATH = t.parent.parent test_eq(repr(t), f&quot;Path(&#39;_notebooks/{t.name}&#39;)&quot;) finally: Path.BASE_PATH = None . def join_path_file(file, path, ext=&#39;&#39;): &quot;Return `path/file` if file is a string or a `Path`, file otherwise&quot; if not isinstance(file, (str, Path)): return file path.mkdir(parents=True, exist_ok=True) return path/f&#39;{file}{ext}&#39; . import shutil . path = Path.cwd()/&#39;_tmp&#39;/&#39;tst&#39; f = join_path_file(&#39;tst.txt&#39;, path) assert path.exists() test_eq(f, path/&#39;tst.txt&#39;) with open(f, &#39;w&#39;) as f_: assert join_path_file(f_, path) == f_ shutil.rmtree(Path.cwd()/&#39;_tmp&#39;) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/04/27/create-your-custom-pathlib-class.html",
            "relUrl": "/fastcore/fastai/python/2020/04/27/create-your-custom-pathlib-class.html",
            "date": " • Apr 27, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Create you custom list objects",
            "content": "This is the third of a series of posts whose aim is to go through the complete development of fastcore and fastai2. . The L class . from fastcore.imports import * from fastcore.foundation import NewChkMeta . is an array?, convert to list . def _is_array(x): return hasattr(x,&#39;__array__&#39;) or hasattr(x,&#39;iloc&#39;) def _listify(o): if o is None: return [] if isinstance(o, list): return o if isinstance(o, str) or _is_array(o): return [o] if is_iter(o): return list(o) return [o] . pretty print . def coll_repr(c, max_n=10): &quot;String repr of up to `max_n` items of (possibly lazy) collection `c`&quot; return f&#39;(#{len(c)}) [&#39; + &#39;,&#39;.join(itertools.islice(map(repr,c), max_n)) + ( &#39;...&#39; if len(c)&gt;10 else &#39;&#39;) + &#39;]&#39; . test_eq(coll_repr(range(1000), 5), &#39;(#1000) [0,1,2,3,4...]&#39;) . def mask2idxs(mask): &quot;Convert bool mask or index list to index `L`&quot; if isinstance(mask,slice): return mask mask = list(mask) if len(mask)==0: return [] it = mask[0] if hasattr(it,&#39;item&#39;): it = it.item() #for torch tensor if isinstance(it,(bool,NoneType,np.bool_)): return [i for i,m in enumerate(mask) if m] return [int(i) for i in mask] . import torch . test_eq(mask2idxs([False,True,False,True]), [1,3]) test_eq(mask2idxs(array([False,True,False,True])), [1,3]) test_eq(mask2idxs(torch.tensor([False,True,False,True])), [1,3]) test_eq(mask2idxs(array([1,2,3])), [1,2,3]) . listable_types = typing.Collection,Generator,map,filter,zip . Basic listy behaviour . class CollBase: &quot;Base class for composing a list of `items`&quot; def __init__(self, items): self.items = items def __len__(self): return len(self.items) def __getitem__(self, k): return self.items[k] def __setitem__(self, k, v): self.items[list(k) if isinstance(k,CollBase) else k] = v def __delitem__(self, i): del(self.items[i]) def __repr__(self): return self.items.__repr__() def __iter__(self): return self.items.__iter__() . put o on a circle . def cycle(o): &quot;Like `itertools.cycle` except creates list of `None`s if `o` is empty&quot; o = _listify(o) return itertools.cycle(o) if o is not None and len(o) &gt; 0 else itertools.cycle([None]) . test_eq(itertools.islice(cycle([1,2,3]),5), [1,2,3,1,2]) test_eq(itertools.islice(cycle([]),3), [None]*3) test_eq(itertools.islice(cycle(None),3), [None]*3) test_eq(itertools.islice(cycle(1),3), [1,1,1]) . all but the first elements are put on a circle before zipping def zip_cycle(x, *args): &quot;Like `itertools.zip_longest` but `cycle`s through elements of all but first argument&quot; return zip(x, *map(cycle,args)) . test_eq(zip_cycle([1,2,3,4],list(&#39;abc&#39;)), [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;a&#39;)]) . def is_indexer(idx): &quot;Test whether `idx` will index a single item in a list&quot; return isinstance(idx,int) or not getattr(idx,&#39;ndim&#39;,1) . def negate_func(f): &quot;Create new function that negates result of `f`&quot; def _f(*args, **kwargs): return not f(*args, **kwargs) return _f . def f(a): return a&gt;0 test_eq(f(1),True) test_eq(negate_func(f)(1),False) test_eq(negate_func(f)(a=-1),True) . From this post, NewChkMeta basically avoids recreating an object of typeL when passed as argument to L.__init__. . class L(CollBase, metaclass=NewChkMeta): &quot;Behaves like a list of `items` but can also index with list of indices or masks&quot; _default=&#39;items&#39; def __init__(self, items=None, *rest, use_list=False, match=None): if rest: items = (items,)+rest if items is None: items = [] if (use_list is not None) or not _is_array(items): items = list(items) if use_list else _listify(items) if match is not None: if is_coll(match): match = len(match) if len(items)==1: items = items*match else: assert len(items)==match, &#39;Match length mismatch&#39; super().__init__(items) @property def _xtra(self): return None def _new(self, items, *args, **kwargs): return type(self)(items, *args, use_list=None, **kwargs) def __getitem__(self, idx): return self._get(idx) if is_indexer(idx) else L(self._get(idx), use_list=None) def copy(self): return self._new(self.items.copy()) def _get(self, i): if is_indexer(i) or isinstance(i,slice): return getattr(self.items,&#39;iloc&#39;,self.items)[i] i = mask2idxs(i) return (self.items.iloc[list(i)] if hasattr(self.items,&#39;iloc&#39;) else self.items.__array__()[(i,)] if hasattr(self.items,&#39;__array__&#39;) else [self.items[i_] for i_ in i]) def __setitem__(self, idx, o): &quot;Set `idx` (can be list of indices, or mask, or int) items to `o` (which is broadcast if not iterable)&quot; if isinstance(idx, int): self.items[idx] = o else: idx = idx if isinstance(idx,L) else _listify(idx) if not is_iter(o): o = [o]*len(idx) for i,o_ in zip(idx,o): self.items[i] = o_ def __iter__(self): return iter(self.items.itertuples() if hasattr(self.items,&#39;iloc&#39;) else self.items) def __contains__(self,b): return b in self.items def __invert__(self): return self._new(not i for i in self) def __eq__(self,b): return False if isinstance(b, (str,dict,set)) else all_equal(b,self) def __repr__(self): return repr(self.items) if _is_array(self.items) else coll_repr(self) def __mul__ (a,b): return a._new(a.items*b) def __add__ (a,b): return a._new(a.items+_listify(b)) def __radd__(a,b): return a._new(b)+a def __addi__(a,b): a.items += list(b) return a def sorted(self, key=None, reverse=False): if isinstance(key,str): k=lambda o:getattr(o,key,0) elif isinstance(key,int): k=itemgetter(key) else: k=key return self._new(sorted(self.items, key=k, reverse=reverse)) @classmethod def split(cls, s, sep=None, maxsplit=-1): return cls(s.split(sep,maxsplit)) @classmethod def range(cls, a, b=None, step=None): if is_coll(a): a = len(a) return cls(range(a,b,step) if step is not None else range(a,b) if b is not None else range(a)) def map(self, f, *args, **kwargs): g = (bind(f,*args,**kwargs) if callable(f) else f.format if isinstance(f,str) else f.__getitem__) return self._new(map(g, self)) def filter(self, f, negate=False, **kwargs): if kwargs: f = partial(f,**kwargs) if negate: f = negate_func(f) return self._new(filter(f, self)) def argwhere(self, f, negate=False, **kwargs): if kwargs: f = partial(f,**kwargs) if negate: f = negate_func(f) return self._new(i for i,o in enumerate(self) if f(o)) def unique(self): return L(dict.fromkeys(self).keys()) def enumerate(self): return L(enumerate(self)) def val2idx(self): return {v:k for k,v in self.enumerate()} def itemgot(self, *idxs): x = self for idx in idxs: x = x.map(itemgetter(idx)) return x def attrgot(self, k, default=None): return self.map(lambda o:getattr(o,k,default)) def cycle(self): return cycle(self) def map_dict(self, f=noop, *args, **kwargs): return {k:f(k, *args,**kwargs) for k in self} def starmap(self, f, *args, **kwargs): return self._new(itertools.starmap(partial(f,*args,**kwargs), self)) def zip(self, cycled=False): return self._new((zip_cycle if cycled else zip)(*self)) def zipwith(self, *rest, cycled=False): return self._new([self, *rest]).zip(cycled=cycled) def map_zip(self, f, *args, cycled=False, **kwargs): return self.zip(cycled=cycled).starmap(f, *args, **kwargs) def map_zipwith(self, f, *rest, cycled=False, **kwargs): return self.zipwith(*rest, cycled=cycled).starmap(f, **kwargs) def concat(self): return self._new(itertools.chain.from_iterable(self.map(L))) def shuffle(self): it = copy(self.items) random.shuffle(it) return self._new(it) def append(self,o): return self.items.append(o) def remove(self,o): return self.items.remove(o) def count (self,o): return self.items.count(o) def reverse(self ): return self.items.reverse() def pop(self,o=-1): return self.items.pop(o) def clear(self ): return self.items.clear() def index(self, value, start=0, stop=sys.maxsize): return self.items.index(value, start, stop) def sort(self, key=None, reverse=False): return self.items.sort(key=key, reverse=reverse) def reduce(self, f, initial=None): return reduce(f, self) if initial is None else reduce(f, self, initial) def sum(self): return self.reduce(operator.add) def product(self): return self.reduce(operator.mul) . You can create an L from an existing iterable (e.g. a list, range, etc) and access or modify it with an int list/tuple index, mask, int, or slice. All list methods can also be used with L. . t = L(range(12)) test_eq(t, list(range(12))) test_ne(t, list(range(11))) t.reverse() test_eq(t[0], 11) t[3] = &quot;h&quot; test_eq(t[3], &quot;h&quot;) t[3,5] = (&quot;j&quot;,&quot;k&quot;) test_eq(t[3,5], [&quot;j&quot;,&quot;k&quot;]) test_eq(t, L(t)) test_eq(L(L(1,2),[3,4]), ([1,2],[3,4])) t . (#12) [11,10,9,&#39;j&#39;,7,&#39;k&#39;,5,4,3,2...] . x = L([[1,2,3], [4,5], [6,7]]) x[0] = [1,2] test_eq(x, L([[1,2], [4,5], [6,7]])) . There are optimized indexers for arrays, tensors, and DataFrames. . import pandas as pd . arr = np.arange(9).reshape(3,3) t = L(arr, use_list=None) test_eq(t[1,2], arr[[1,2]]) arr = np.arange(9).reshape(3,3) t = L(arr, use_list=None) test_eq(t[1,2], arr[[1,2]]) df = pd.DataFrame({&#39;a&#39;:[1,2,3]}) t = L(df, use_list=None) test_eq(t[1,2], L(pd.DataFrame({&#39;a&#39;:[2,3]}, index=[1,2]), use_list=None)) . You can also modify an L with append, +, and *. . t = L() test_eq(t, []) t.append(1) test_eq(t, [1]) t += [3,2] test_eq(t, [1,3,2]) t = t + [4] test_eq(t, [1,3,2,4]) t = 5 + t test_eq(t, [5,1,3,2,4]) test_eq(L(1,2,3), [1,2,3]) test_eq(L(1,2,3), L(1,2,3)) t = L(1)*5 t = t.map(operator.neg) test_eq(t,[-1]*5) test_eq(~L([True,False,False]), L([False,True,True])) t = L(range(4)) test_eq(zip(t, L(1).cycle()), zip(range(4),(1,1,1,1))) t = L.range(100) test_shuffled(t,t.shuffle()) . def _f(x,a=0): return x+a t = L(1)*5 test_eq(t.map(_f), t) test_eq(t.map(_f,1), [2]*5) test_eq(t.map(_f,a=2), [3]*5) . An L can be constructed from anything iterable, although tensors and arrays will not be iterated over on construction, unless you pass use_list to the constructor. . test_eq(L([1,2,3]),[1,2,3]) test_eq(L(L([1,2,3])),[1,2,3]) test_ne(L([1,2,3]),[1,2,]) test_eq(L(&#39;abc&#39;),[&#39;abc&#39;]) test_eq(L(range(0,3)),[0,1,2]) test_eq(L(o for o in range(0,3)),[0,1,2]) test_eq(L(array(0)),[array(0)]) test_eq(L([array(0),array(1)]),[array(0),array(1)]) test_eq(L(array([0.,1.1]))[0],array([0.,1.1])) test_eq(L(array([0.,1.1]), use_list=True), [array(0.),array(1.1)]) # `use_list=True` to unwrap arrays/arrays . If match is not None then the created list is same len as match, either by: . If len(items)==1 then items is replicated, | Otherwise an error is raised if match and items are not already the same size. | . test_eq(L(1,match=[1,2,3]),[1,1,1]) test_eq(L([1,2],match=[2,3]),[1,2]) test_fail(lambda: L([1,2],match=[1,2,3])) . If you create an L from an existing L then you&#39;ll get back the original object (since L uses the NewChkMeta metaclass). . test_is(L(t), t) . An L is considred equal to a list if they have the same elements. It&#39;s never considered equal to a str a set or a dict even if they have the same elements/keys. . test_eq(L([&#39;a&#39;, &#39;b&#39;]), [&#39;a&#39;, &#39;b&#39;]) test_ne(L([&#39;a&#39;, &#39;b&#39;]), &#39;ab&#39;) test_ne(L([&#39;a&#39;, &#39;b&#39;]), {&#39;a&#39;, &#39;b&#39;}) test_ne(L([&#39;a&#39;, &#39;b&#39;]), {&#39;a&#39;:1, &#39;b&#39;:2}) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/04/25/create-your-custom-list-type.html",
            "relUrl": "/fastcore/fastai/python/2020/04/25/create-your-custom-list-type.html",
            "date": " • Apr 25, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastcore 01",
            "content": "This is the second of a series of posts whose aim is to go through the complete development of fastcore and fastai2. See this post for a brief overview of metaclasses and references thereof. . from fastcore.imports import * . Core . Basic functions used in the fastai library . Metaclasses . Actually I&#39;m not sure FixSigMeta does anything for now, because if I don´t fix the signature and inherit from a metaclass (which doesn´t overwrite __init__), the signature stays the same. . class FixSigMeta(type): &quot;A metaclass that fixes the signature on classes that override __init__&quot; def __new__(cls, name, bases, dict): res = super().__new__(cls, name, bases, dict) if res.__init__ is not object.__init__: res.__signature__ = inspect.signature(res.__init__) return res . I&#39;m curious about when type(cls.__new__(cls))!=cls. Note that cls is the class inheriting from this metaclass. . class PrePostInitMeta(FixSigMeta): &quot;A metaclass that calls optional `__pre_init__` and `__post_init__` methods&quot; def __call__(cls, *args, **kwargs): res = cls.__new__(cls) if type(res)==cls: if hasattr(res,&#39;__pre_init__&#39;): res.__pre_init__(*args,**kwargs) res.__init__(*args,**kwargs) if hasattr(res,&#39;__post_init__&#39;): res.__post_init__(*args,**kwargs) return res . Here is a simple test . class _T(metaclass=PrePostInitMeta): def __pre_init__(self): self.a = 0; assert self.a==0 def __init__(self,b=0): self.a += 1; assert self.a==1 def __post_init__(self): self.a += 1; assert self.a==2 t = _T() test_eq(t.a, 2) . The metaclass below avoids recreating x when x is passed as the sole argument to cls if x is an instance of cls (x.__class__=cls or equivalently isinstance(x, cls)==True). It also adds the property _newchk to x which tracks if x has been passed as the sole argument to its class (x._newchk=1) or not (x._newchk=0). . class NewChkMeta(FixSigMeta): &quot;Metaclass to avoid recreating object passed to constructor&quot; def __call__(cls, x=None, *args, **kwargs): if not args and not kwargs and x is not None and isinstance(x,cls): x._newchk = 1 return x res = super().__call__(*((x,) + args), **kwargs) res._newchk = 0 return res . class _T(metaclass=NewChkMeta): &quot;Testing&quot; def __init__(self, o=None, b=1): self.foo = getattr(o,&#39;foo&#39;,0) + 1 self.b = b . class _T2(): def __init__(self, o): self.foo = getattr(o,&#39;foo&#39;,0) + 1 . Below, t is passed as the sole argument to _T and thus, because of its metaclass, it is returned as it is and no new object is created . t = _T(1) test_eq(t.foo,1) t2 = _T(t) test_eq(t2.foo,1) test_is(t,t2) . Below, t is passed not as the sole argument, so a new object t3 different from t is created . t3 = _T(t, b=2) test_eq(t3.b, 2) assert not t3 is t . Observe that t2 is different from t unlike above (_T2 doesn&#39;t inherits from the metaclass). . t = _T2(1) test_eq(t.foo,1) t2 = _T2(t) test_eq(t2.foo,2) test_eq(_T.__doc__, &quot;Testing&quot;) # TODO: this shouldn&#39;t have &quot;self, &quot; test_eq(str(inspect.signature(_T)), &#39;(self, o=None, b=1)&#39;) . If cls has the attribute _bypass_type, and x is of this type (and is the sole, x argument, its type will by fixed to cls. Furthermore, if cls has the method _new_meta, x will by initialized by it. . class BypassNewMeta(FixSigMeta): &quot;Metaclass: casts `x` to this class if it&#39;s of type `cls._bypass_type`, initializing with `_new_meta` if available&quot; def __call__(cls, x=None, *args, **kwargs): if hasattr(cls, &#39;_new_meta&#39;): x = cls._new_meta(x, *args, **kwargs) elif not isinstance(x,getattr(cls,&#39;_bypass_type&#39;,object)) or len(args) or len(kwargs): x = super().__call__(*((x,)+args), **kwargs) if cls!=x.__class__: x.__class__ = cls return x . class T0: pass class _T(T0, metaclass=BypassNewMeta): _bypass_type=T0 def __init__(self,x): self.x=x t = T0() t.a = 1 t2 = _T(t) test_eq(type(t2), _T) test_eq(t2.a,1) test_is(t2,t) t = _T(2) t.x = 2 . Foundational functions . copy.copy doesn´t work to copy functions, so we have to create a new one with all the same attributes. . def copy_func(f): &quot;Copy a non-builtin function (NB `copy.copy` does not work for this)&quot; if not isinstance(f,FunctionType): return copy(f) fn = FunctionType(f.__code__, f.__globals__, f.__name__, f.__defaults__, f.__closure__) fn.__dict__.update(f.__dict__) return fn . Function wrapper that adds f to cls which can be either a class or a tuple/list of classes. If as_prop==True, f is added as property. . def patch_to(cls, as_prop=False): &quot;Decorator: add `f` to `cls`&quot; if not isinstance(cls, (tuple,list)): cls=(cls,) def _inner(f): for c_ in cls: nf = copy_func(f) # `functools.update_wrapper` when passing patched function to `Pipeline`, so we do it manually for o in functools.WRAPPER_ASSIGNMENTS: setattr(nf, o, getattr(f,o)) nf.__qualname__ = f&quot;{c_.__name__}.{f.__name__}&quot; setattr(c_, f.__name__, property(nf) if as_prop else nf) return f return _inner . class _T3(int): pass @patch_to(_T3) def func1(x, a): return x+a t = _T3(1) test_eq(t.func1(2), 3) . class _T4(int): pass @patch_to((_T3,_T4)) def func2(x, a): return x+2*a t = _T3(1) test_eq(t.func2(1), 3) t = _T4(1) test_eq(t.func2(1), 3) . By reading fs type annotations, this decorator add&#39;s f to the type of f&#39;s first argument. . def patch(f): &quot;Decorator: add `f` to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls)(f) . @patch def func(x:_T3, a): &quot;test&quot; return x+2 t = _T3(1) test_eq(t.func(2), 3) test_eq(t.func.__qualname__, &#39;_T3.func&#39;) . @patch def func3(x:(_T3,_T4), a): &quot;test&quot; return x+2*a t = _T3(1) test_eq(t.func3(2), 5) test_eq(t.func3.__qualname__, &#39;_T3.func3&#39;) t = _T4(1) test_eq(t.func3(2), 5) test_eq(t.func3.__qualname__, &#39;_T4.func3&#39;) . Same as above, but with as_prop==True. . def patch_property(f): &quot;Decorator: add `f` as a property to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls, as_prop=True)(f) . @patch_property def prop(x:_T3): return x+1 t = _T3(1) test_eq(t.prop, 2) . Create paramter named n with value d . def _mk_param(n,d=None): return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d) . Test that fs signature is b. . def test_sig(f, b): test_eq(str(inspect.signature(f)), b) . replace (if keep=False, otherwise add to) f&#39;s signature **kwargs with the descorator&#39;s **kwargs . def use_kwargs_dict(keep=False, **kwargs): &quot;Decorator: replace `**kwargs` in signature with `names` params&quot; def _f(f): sig = inspect.signature(f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . * specifies the end of regular arguments and the start of keyword arguments . @use_kwargs_dict(y=1,z=None) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, *, y=1, z=None)&#39;) . Same as use_kwargs_dict but adds arguments with keys names and values None. . def use_kwargs(names, keep=False): &quot;Decorator: replace `**kwargs` in signature with `names` params&quot; def _f(f): sig = inspect.signature(f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {n:_mk_param(n) for n in names if n not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . @use_kwargs([&#39;y&#39;, &#39;z&#39;]) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, *, y=None, z=None)&#39;) @use_kwargs([&#39;y&#39;, &#39;z&#39;], keep=True) def foo(a, *args, b=1, **kwargs): pass test_sig(foo, &#39;(a, *args, b=1, y=None, z=None, **kwargs)&#39;) . Here if to is None, f is assumed to be a class and it replaces (if keep==False) the kwargs of its __init__ with the named params of its base class. . def delegates(to=None, keep=False): &quot;Decorator: replace `**kwargs` in signature with params from `to`&quot; def _f(f): if to is None: to_f,from_f = f.__base__.__init__,f.__init__ else: to_f,from_f = to,f from_f = getattr(from_f,&#39;__func__&#39;,from_f) if hasattr(from_f,&#39;__delwrap__&#39;): return f sig = inspect.signature(from_f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {k:v for k,v in inspect.signature(to_f).parameters.items() if v.default != inspect.Parameter.empty and k not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k else: from_f.__delwrap__ = to_f from_f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . def basefoo(e, c=2): pass @delegates(basefoo) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, c=2)&#39;) @delegates(basefoo, keep=True) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, c=2, **kwargs)&#39;) . class BaseFoo: def __init__(self, e, c=2): pass @delegates() class Foo(BaseFoo): def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs) test_sig(Foo, &#39;(a, b=1, c=2)&#39;) . Replace cls._methods by those in **kwargs. If one of them is of type MethodType it&#39;s object is changed to self. Also, the signature of __init__ is updated. . def funcs_kwargs(cls): &quot;Replace methods in `self._methods` with those from `kwargs`&quot; old_init = cls.__init__ def _init(self, *args, **kwargs): for k in cls._methods: arg = kwargs.pop(k,None) if arg is not None: if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self) setattr(self, k, arg) old_init(self, *args, **kwargs) functools.update_wrapper(_init, old_init) cls.__init__ = use_kwargs(cls._methods)(_init) return cls . def method(f): &quot;Mark `f` as a method&quot; # `1` is a dummy instance since Py3 doesn&#39;t allow `None` any more return MethodType(f, 1) . @funcs_kwargs class T: _methods=[&#39;b&#39;] def __init__(self, f=1, **kwargs): assert not kwargs def a(self): return 1 def b(self): return 2 t = T() test_eq(t.a(), 1) test_eq(t.b(), 2) t = T(b = lambda:3) test_eq(t.b(), 3) test_sig(T, &#39;(f=1, *, b=None)&#39;) test_fail(lambda: T(a = lambda:3)) @method def _f(self,a=1): return a+1 t = T(b = _f) test_eq(t.b(2), 3) class T2(T): def __init__(self,a): super().__init__(b = lambda:3) self.a=a t = T2(a=1) test_eq(t.b(), 3) test_sig(T2, &#39;(a)&#39;) def _g(a=1): return a+1 class T3(T): b = staticmethod(_g) t = T3() test_eq(t.b(2), 3) . This creates a context manager pretty much like with open(...) as heendle: where everything before the yield is excecuted before the block under with, then that block is excecuted, and finally, everything after yield. . @contextmanager def working_directory(path): &quot;Change working directory to `path` and return to previous on exit.&quot; prev_cwd = Path.cwd() os.chdir(path) try: yield finally: os.chdir(prev_cwd) . Add docstrings from arguments. . def add_docs(cls, cls_doc=None, **docs): &quot;Copy values from `docs` to `cls` docstrings, and confirm all public methods are documented&quot; if cls_doc is not None: cls.__doc__ = cls_doc for k,v in docs.items(): f = getattr(cls,k) if hasattr(f,&#39;__func__&#39;): f = f.__func__ # required for class methods f.__doc__ = v # List of public callables without docstring nodoc = [c for n,c in vars(cls).items() if callable(c) and not n.startswith(&#39;_&#39;) and c.__doc__ is None] assert not nodoc, f&quot;Missing docs: {nodoc}&quot; assert cls.__doc__ is not None, f&quot;Missing class docs: {cls}&quot; . def docs(cls): &quot;Decorator version of `add_docs`, using `_docs` dict&quot; add_docs(cls, **cls._docs) return cls . class _T: def f(self): pass @classmethod def g(cls): pass add_docs(_T, &quot;a&quot;, f=&quot;f&quot;, g=&quot;g&quot;) test_eq(_T.__doc__, &quot;a&quot;) test_eq(_T.f.__doc__, &quot;f&quot;) test_eq(_T.g.__doc__, &quot;g&quot;) . Below is an implementation of partial which allows you to specify the arguments being partially evaluated through _Arg instances. . class _Arg: def __init__(self,i): self.i = i arg0 = _Arg(0) arg1 = _Arg(1) arg2 = _Arg(2) arg3 = _Arg(3) arg4 = _Arg(4) . class bind: &quot;Same as `partial`, except you can use `arg0` `arg1` etc param placeholders&quot; def __init__(self, fn, *pargs, **pkwargs): self.fn,self.pargs,self.pkwargs = fn,pargs,pkwargs self.maxi = max((x.i for x in pargs if isinstance(x, _Arg)), default=-1) def __call__(self, *args, **kwargs): args = list(args) kwargs = {**self.pkwargs,**kwargs} for k,v in kwargs.items(): if isinstance(v,_Arg): kwargs[k] = args.pop(v.i) fargs = [args[x.i] if isinstance(x, _Arg) else x for x in self.pargs] + args[self.maxi+1:] return self.fn(*fargs, **kwargs) . def myfn(a,b,c,d=1,e=2): return(a,b,c,d,e) test_eq(bind(myfn, arg1, 17, arg0, e=3)(19,14), (14,17,19,1,3)) test_eq(bind(myfn, 17, arg0, e=3)(19,14), (17,19,14,1,3)) test_eq(bind(myfn, 17, e=3)(19,14), (17,19,14,1,3)) test_eq(bind(myfn)(17,19,14), (17,19,14,1,2)) test_eq(bind(myfn, 17,19,14,e=arg0)(3), (17,19,14,1,3)) . def custom_dir(c, add:list): &quot;Implement custom `__dir__`, adding `add` to `cls`&quot; return dir(type(c)) + list(c.__dict__.keys()) + add . if self._xtra is None, all attributes of self.default are passed to self. If self._xtra is not None, only those in self._xtra are passed along. . class GetAttr: &quot;Inherit from this to have all attr accesses in `self._xtra` passed down to `self.default`&quot; _default=&#39;default&#39; def _component_attr_filter(self,k): if k.startswith(&#39;__&#39;) or k in (&#39;_xtra&#39;,self._default): return False xtra = getattr(self,&#39;_xtra&#39;,None) return xtra is None or k in xtra def _dir(self): return [k for k in dir(getattr(self,self._default)) if self._component_attr_filter(k)] def __getattr__(self,k): if self._component_attr_filter(k): attr = getattr(self,self._default,None) if attr is not None: return getattr(attr,k) raise AttributeError(k) def __dir__(self): return custom_dir(self,self._dir()) # def __getstate__(self): return self.__dict__ def __setstate__(self,data): self.__dict__.update(data) . Inherit from GetAttr to have attr access passed down to an instance attribute. This makes it easy to create composites that don&#39;t require callers to know about their components. . You can customise the behaviour of GetAttr in subclasses via; . _default By default, this is set to &#39;default&#39;, so attr access is passed down to self.default | _default can be set to the name of any instance attribute that does not start with dunder __ | . | _xtra By default, this is None, so all attr access is passed down | You can limit which attrs get passed down by setting _xtra to a list of attribute names | . | . class _C(GetAttr): # allow all attributes to get passed to `self.default` (by leaving _xtra=None) def __init__(self,a): self.default = a def foo(self): noop t = _C(&#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_eq(t.upper(), &#39;HI&#39;) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; in dir(t) . class _C(GetAttr): _xtra = [&#39;lower&#39;] # specify which attributes get passed to `self.default` def __init__(self,a): self.default = a def foo(self): noop . t = _C(&#39;Hi&#39;) test_eq(t.default, &#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_fail(lambda: t.upper()) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; not in dir(t) . class _C(GetAttr): _default = &#39;_data&#39; # use different component name; `self._data` rather than `self.default` def __init__(self,a): self._data = a def foo(self): noop . t = _C(&#39;Hi&#39;) test_eq(t._data, &#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_eq(t.upper(), &#39;HI&#39;) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; in dir(t) . class _C(GetAttr): _default = &#39;data&#39; # use a bad component name; i.e. self.data does not exist def __init__(self,a): self.default = a def foo(self): noop # TODO: should we raise an error when we create a new instance ... t = _C(&#39;Hi&#39;) test_eq(t.default, &#39;Hi&#39;) # ... or is it enough for all GetAttr features to raise errors test_fail(lambda: t.data) test_fail(lambda: t.lower()) test_fail(lambda: t.upper()) test_fail(lambda: dir(t)) . class _C(GetAttr): _xtra = [&#39;lower&#39;, &#39;upper&#39;] _default = &#39;data&#39; def __init__(self,a): self.data = a def foo(self): noop t = _C(&#39;Hi&#39;) test_eq(t.data, &#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_eq(t.upper(), &#39;HI&#39;) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; in dir(t) . class _C(GetAttr): def __init__(self): self.default = type(&#39;_D&#39;, (), {&#39;_under&#39;: 1, &#39;__dunder&#39;: 2})() t = _C() test_eq(t.default._under, 1) test_eq(t._under, 1) # _ prefix attr access is allowed on component assert &#39;_under&#39; in dir(t) test_eq(t.default.__dunder, 2) test_fail(lambda: t.__dunder) # __ prefix attr access is not allowed on component assert &#39;__dunder&#39; not in dir(t) assert t.__dir__ is not None # __ prefix attr access is allowed on composite assert &#39;__dir__&#39; in dir(t) . def delegate_attr(self, k, to): &quot;Use in `__getattr__` to delegate to attr `to` without inheriting from `GetAttr`&quot; if k.startswith(&#39;_&#39;) or k==to: raise AttributeError(k) try: return getattr(getattr(self,to), k) except AttributeError: raise AttributeError(k) from None class _C: f = &#39;Hi&#39; def __getattr__(self, k): return delegate_attr(self, k, &#39;f&#39;) t = _C() test_eq(t.lower(), &#39;hi&#39;) . def _is_array(x): return hasattr(x,&#39;__array__&#39;) or hasattr(x,&#39;iloc&#39;) def _listify(o): if o is None: return [] if isinstance(o, list): return o if isinstance(o, str) or _is_array(o): return [o] if is_iter(o): return list(o) return [o] . def coll_repr(c, max_n=10): &quot;String repr of up to `max_n` items of (possibly lazy) collection `c`&quot; return f&#39;(#{len(c)}) [&#39; + &#39;,&#39;.join(itertools.islice(map(repr,c), max_n)) + ( &#39;...&#39; if len(c)&gt;10 else &#39;&#39;) + &#39;]&#39; . test_eq(coll_repr(range(1000), 5), &#39;(#1000) [0,1,2,3,4...]&#39;) . def mask2idxs(mask): &quot;Convert bool mask or index list to index `L`&quot; if isinstance(mask,slice): return mask mask = list(mask) if len(mask)==0: return [] it = mask[0] if hasattr(it,&#39;item&#39;): it = it.item() if isinstance(it,(bool,NoneType,np.bool_)): return [i for i,m in enumerate(mask) if m] return [int(i) for i in mask] . import torch . test_eq(mask2idxs([False,True,False,True]), [1,3]) test_eq(mask2idxs(array([False,True,False,True])), [1,3]) test_eq(mask2idxs(torch.tensor([False,True,False,True])), [1,3]) test_eq(mask2idxs(array([1,2,3])), [1,2,3]) . listable_types = typing.Collection,Generator,map,filter,zip . class CollBase: &quot;Base class for composing a list of `items`&quot; def __init__(self, items): self.items = items def __len__(self): return len(self.items) def __getitem__(self, k): return self.items[k] def __setitem__(self, k, v): self.items[list(k) if isinstance(k,CollBase) else k] = v def __delitem__(self, i): del(self.items[i]) def __repr__(self): return self.items.__repr__() def __iter__(self): return self.items.__iter__() . def cycle(o): &quot;Like `itertools.cycle` except creates list of `None`s if `o` is empty&quot; o = _listify(o) return itertools.cycle(o) if o is not None and len(o) &gt; 0 else itertools.cycle([None]) . test_eq(itertools.islice(cycle([1,2,3]),5), [1,2,3,1,2]) test_eq(itertools.islice(cycle([]),3), [None]*3) test_eq(itertools.islice(cycle(None),3), [None]*3) test_eq(itertools.islice(cycle(1),3), [1,1,1]) . def zip_cycle(x, *args): &quot;Like `itertools.zip_longest` but `cycle`s through elements of all but first argument&quot; return zip(x, *map(cycle,args)) . test_eq(zip_cycle([1,2,3,4],list(&#39;abc&#39;)), [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;a&#39;)]) . def is_indexer(idx): &quot;Test whether `idx` will index a single item in a list&quot; return isinstance(idx,int) or not getattr(idx,&#39;ndim&#39;,1) . def negate_func(f): &quot;Create new function that negates result of `f`&quot; def _f(*args, **kwargs): return not f(*args, **kwargs) return _f . def f(a): return a&gt;0 test_eq(f(1),True) test_eq(negate_func(f)(1),False) test_eq(negate_func(f)(a=-1),True) . class L(CollBase, metaclass=NewChkMeta): &quot;Behaves like a list of `items` but can also index with list of indices or masks&quot; _default=&#39;items&#39; def __init__(self, items=None, *rest, use_list=False, match=None): if rest: items = (items,)+rest if items is None: items = [] if (use_list is not None) or not _is_array(items): items = list(items) if use_list else _listify(items) if match is not None: if is_coll(match): match = len(match) if len(items)==1: items = items*match else: assert len(items)==match, &#39;Match length mismatch&#39; super().__init__(items) @property def _xtra(self): return None def _new(self, items, *args, **kwargs): return type(self)(items, *args, use_list=None, **kwargs) def __getitem__(self, idx): return self._get(idx) if is_indexer(idx) else L(self._get(idx), use_list=None) def copy(self): return self._new(self.items.copy()) def _get(self, i): if is_indexer(i) or isinstance(i,slice): return getattr(self.items,&#39;iloc&#39;,self.items)[i] i = mask2idxs(i) return (self.items.iloc[list(i)] if hasattr(self.items,&#39;iloc&#39;) else self.items.__array__()[(i,)] if hasattr(self.items,&#39;__array__&#39;) else [self.items[i_] for i_ in i]) def __setitem__(self, idx, o): &quot;Set `idx` (can be list of indices, or mask, or int) items to `o` (which is broadcast if not iterable)&quot; if isinstance(idx, int): self.items[idx] = o else: idx = idx if isinstance(idx,L) else _listify(idx) if not is_iter(o): o = [o]*len(idx) for i,o_ in zip(idx,o): self.items[i] = o_ def __iter__(self): return iter(self.items.itertuples() if hasattr(self.items,&#39;iloc&#39;) else self.items) def __contains__(self,b): return b in self.items def __invert__(self): return self._new(not i for i in self) def __eq__(self,b): return False if isinstance(b, (str,dict,set)) else all_equal(b,self) def __repr__(self): return repr(self.items) if _is_array(self.items) else coll_repr(self) def __mul__ (a,b): return a._new(a.items*b) def __add__ (a,b): return a._new(a.items+_listify(b)) def __radd__(a,b): return a._new(b)+a def __addi__(a,b): a.items += list(b) return a def sorted(self, key=None, reverse=False): if isinstance(key,str): k=lambda o:getattr(o,key,0) elif isinstance(key,int): k=itemgetter(key) else: k=key return self._new(sorted(self.items, key=k, reverse=reverse)) @classmethod def split(cls, s, sep=None, maxsplit=-1): return cls(s.split(sep,maxsplit)) @classmethod def range(cls, a, b=None, step=None): if is_coll(a): a = len(a) return cls(range(a,b,step) if step is not None else range(a,b) if b is not None else range(a)) def map(self, f, *args, **kwargs): g = (bind(f,*args,**kwargs) if callable(f) else f.format if isinstance(f,str) else f.__getitem__) return self._new(map(g, self)) def filter(self, f, negate=False, **kwargs): if kwargs: f = partial(f,**kwargs) if negate: f = negate_func(f) return self._new(filter(f, self)) def argwhere(self, f, negate=False, **kwargs): if kwargs: f = partial(f,**kwargs) if negate: f = negate_func(f) return self._new(i for i,o in enumerate(self) if f(o)) def unique(self): return L(dict.fromkeys(self).keys()) def enumerate(self): return L(enumerate(self)) def val2idx(self): return {v:k for k,v in self.enumerate()} def itemgot(self, *idxs): x = self for idx in idxs: x = x.map(itemgetter(idx)) return x def attrgot(self, k, default=None): return self.map(lambda o:getattr(o,k,default)) def cycle(self): return cycle(self) def map_dict(self, f=noop, *args, **kwargs): return {k:f(k, *args,**kwargs) for k in self} def starmap(self, f, *args, **kwargs): return self._new(itertools.starmap(partial(f,*args,**kwargs), self)) def zip(self, cycled=False): return self._new((zip_cycle if cycled else zip)(*self)) def zipwith(self, *rest, cycled=False): return self._new([self, *rest]).zip(cycled=cycled) def map_zip(self, f, *args, cycled=False, **kwargs): return self.zip(cycled=cycled).starmap(f, *args, **kwargs) def map_zipwith(self, f, *rest, cycled=False, **kwargs): return self.zipwith(*rest, cycled=cycled).starmap(f, **kwargs) def concat(self): return self._new(itertools.chain.from_iterable(self.map(L))) def shuffle(self): it = copy(self.items) random.shuffle(it) return self._new(it) def append(self,o): return self.items.append(o) def remove(self,o): return self.items.remove(o) def count (self,o): return self.items.count(o) def reverse(self ): return self.items.reverse() def pop(self,o=-1): return self.items.pop(o) def clear(self ): return self.items.clear() def index(self, value, start=0, stop=sys.maxsize): return self.items.index(value, start, stop) def sort(self, key=None, reverse=False): return self.items.sort(key=key, reverse=reverse) def reduce(self, f, initial=None): return reduce(f, self) if initial is None else reduce(f, self, initial) def sum(self): return self.reduce(operator.add) def product(self): return self.reduce(operator.mul) . You can create an L from an existing iterable (e.g. a list, range, etc) and access or modify it with an int list/tuple index, mask, int, or slice. All list methods can also be used with L. . t = L(range(12)) test_eq(t, list(range(12))) test_ne(t, list(range(11))) t.reverse() test_eq(t[0], 11) t[3] = &quot;h&quot; test_eq(t[3], &quot;h&quot;) t[3,5] = (&quot;j&quot;,&quot;k&quot;) test_eq(t[3,5], [&quot;j&quot;,&quot;k&quot;]) test_eq(t, L(t)) test_eq(L(L(1,2),[3,4]), ([1,2],[3,4])) t . (#12) [11,10,9,&#39;j&#39;,7,&#39;k&#39;,5,4,3,2...] . x = L([[1,2,3], [4,5], [6,7]]) x[0] = [1,2] test_eq(x, L([[1,2], [4,5], [6,7]])) . There are optimized indexers for arrays, tensors, and DataFrames. . import pandas as pd . arr = np.arange(9).reshape(3,3) t = L(arr, use_list=None) test_eq(t[1,2], arr[[1,2]]) arr = np.arange(9).reshape(3,3) t = L(arr, use_list=None) test_eq(t[1,2], arr[[1,2]]) df = pd.DataFrame({&#39;a&#39;:[1,2,3]}) t = L(df, use_list=None) test_eq(t[1,2], L(pd.DataFrame({&#39;a&#39;:[2,3]}, index=[1,2]), use_list=None)) . You can also modify an L with append, +, and *. . t = L() test_eq(t, []) t.append(1) test_eq(t, [1]) t += [3,2] test_eq(t, [1,3,2]) t = t + [4] test_eq(t, [1,3,2,4]) t = 5 + t test_eq(t, [5,1,3,2,4]) test_eq(L(1,2,3), [1,2,3]) test_eq(L(1,2,3), L(1,2,3)) t = L(1)*5 t = t.map(operator.neg) test_eq(t,[-1]*5) test_eq(~L([True,False,False]), L([False,True,True])) t = L(range(4)) test_eq(zip(t, L(1).cycle()), zip(range(4),(1,1,1,1))) t = L.range(100) test_shuffled(t,t.shuffle()) . def _f(x,a=0): return x+a t = L(1)*5 test_eq(t.map(_f), t) test_eq(t.map(_f,1), [2]*5) test_eq(t.map(_f,a=2), [3]*5) . An L can be constructed from anything iterable, although tensors and arrays will not be iterated over on construction, unless you pass use_list to the constructor. . test_eq(L([1,2,3]),[1,2,3]) test_eq(L(L([1,2,3])),[1,2,3]) test_ne(L([1,2,3]),[1,2,]) test_eq(L(&#39;abc&#39;),[&#39;abc&#39;]) test_eq(L(range(0,3)),[0,1,2]) test_eq(L(o for o in range(0,3)),[0,1,2]) test_eq(L(array(0)),[array(0)]) test_eq(L([array(0),array(1)]),[array(0),array(1)]) test_eq(L(array([0.,1.1]))[0],array([0.,1.1])) test_eq(L(array([0.,1.1]), use_list=True), [array(0.),array(1.1)]) # `use_list=True` to unwrap arrays/arrays . If match is not None then the created list is same len as match, either by: . If len(items)==1 then items is replicated, | Otherwise an error is raised if match and items are not already the same size. | . test_eq(L(1,match=[1,2,3]),[1,1,1]) test_eq(L([1,2],match=[2,3]),[1,2]) test_fail(lambda: L([1,2],match=[1,2,3])) . If you create an L from an existing L then you&#39;ll get back the original object (since L uses the NewChkMeta metaclass). . test_is(L(t), t) . An L is considred equal to a list if they have the same elements. It&#39;s never considered equal to a str a set or a dict even if they have the same elements/keys. . test_eq(L([&#39;a&#39;, &#39;b&#39;]), [&#39;a&#39;, &#39;b&#39;]) test_ne(L([&#39;a&#39;, &#39;b&#39;]), &#39;ab&#39;) test_ne(L([&#39;a&#39;, &#39;b&#39;]), {&#39;a&#39;, &#39;b&#39;}) test_ne(L([&#39;a&#39;, &#39;b&#39;]), {&#39;a&#39;:1, &#39;b&#39;:2}) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/04/23/fastcore-foundations.html",
            "relUrl": "/fastcore/fastai/python/2020/04/23/fastcore-foundations.html",
            "date": " • Apr 23, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Roger Penrose",
            "content": ". A proof of a statement $p$, is a sequence of statements which follow logically from a set of axioms and ends with the statement $p$. For any given sequence ending in $p$, a computer could verify wether it constitutes a proof or not. . On november of 1931, Kurt Gödel, sent waves through the mathematical world by publishing On Formally Undecidable Propositions of Principia Mathematica and Related Systems. In this paper, Kurt shows that given any formal system, you can build a statement $q$ which you can see is true, but it cannot be proved within that system. i.e., thre is no formally verifiable sequence of statements within that system that ends with $q$. . What does it mean you can see in the paragraph above? . Warning: I haven&#8217;t studied the proof myself. . This you can see has to do with the meaning of symbols, and thus, with understanding (I know, equally foggie terms). For a machine it does not makes sense to think of it as true, unless the statement itself is appended to the formal system as an axiom. We humans, by the meaning attached to the symbols, can conceive of that statement as being true. . Roger wonders were this understanding comes from. In going through each physical theory, his argument is that (almost) all of them can be put into a computer 1. You can run black hole simulations on a computer and you can even put the Schrödinger equation in it. However, according to him 2, quantum mechanics is incomplete, especifically, because of the collapse of the wave function. This collapse is not in the equation. There is not sistemathic theory which characterizes what constitutes and observation and what doesn&#39;t. Roger believes this is where a tentative building block of consciousness might be found. . 1. A computer can obtain solutions, given enough time, with arbitrary precision. One might wonder if this closeness is close enough.↩ . 2. He also quotes authority here: Einstein, Schrödinger, and Dirac↩ .",
            "url": "https://juan-carlos-calvo.github.io/blog/podcast/physics/consciousness/philosophy/roger%20penrose/2020/04/04/roger-penrose-ai-podcast.html",
            "relUrl": "/podcast/physics/consciousness/philosophy/roger%20penrose/2020/04/04/roger-penrose-ai-podcast.html",
            "date": " • Apr 4, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Metaclasses",
            "content": "When we instantiate a class, we create an object with a memory location. . class Foo: pass o = Foo() print(o) . &lt;__main__.Foo object at 0x11a6b29b0&gt; . for example the above object is located at . hex(id(o)) . &#39;0x11aec27f0&#39; . similarly, when the above class was created, it also created an object with a memory location. Namely, . hex(id(Foo)) . &#39;0x7fb89764d9b8&#39; . What&#39;s more, just as we can find out the class of o, we can learn what&#39;s the class of Foo . o.__class__ . __main__.Foo . Foo.__class__ . type . that&#39;s right. The same built in method we use to find the type of objects. . Is type also an object? what&#39;s its class? . type.__class__ . type . type itself. So is not turttles all the way down. . When an object is created, its class calls __new__ which if it hasn´t been explicitly defined, it is inherited from its parent class. And, if the parent class hasn´t been explicitly defined, it is the class object. Thus, o is created by object.__new__ . o = object.__new__(Foo) . Just as o is created by the method __new__ of object . Foo is created by the method __new__ of type . Foo = type.__new__(type, &#39;Foo&#39;, (), {}) . or more simply . Foo = type(&#39;Foo&#39;, (), {}) . Since type allow us to create classes the same way a class allow us to create objects, type is called a metaclass. . In the tuple and dictionary above, we can pass base classes and attributes/methods respectively, that define the class. For example: . for . class Faa: pass . . Foo = type(&#39;Foo&#39;, (Faa, ), {&#39;attr&#39;: 100, &#39;attr_val&#39;: lambda x : x.attr}) . is equivalent to . class Foo(Faa): attr = 100 def attr_val(self): return self.attr . Now let&#39;s suppose we wanted to customize the creation of all classes so that all classes&#39;s methods get timed. One option would be to modify type.__new__ so that all methods in the dictionary argument get decorated with . import types import time from functools import wraps def timeit(f): @wraps(f) def wrapper(*args, **kwargs): start = time.time() resp = f(*args, **kwargs) end = time.time() return (resp, end - start) return wrapper . However, python doesn´t let us modify type&#39;s methods. Instead, it allow us to create a class inheriting from type (a metaclass), create our own __new__ method, . class TimeMeta(type): def __new__(cls, name, bases, attr):# Replace each function with a decorated version of the function for name, value in attr.items(): if type(value) is types.FunctionType or type(value) is types.MethodType: attr[name] = timeit(value) # Return a new type called TimeMeta return super().__new__(cls, name, bases, attr) . and then define classes using this new created metaclass. . class Animal(metaclass=TimeMeta): def talk(self): time.sleep(1) print(&quot;Animal talk&quot;) . a = Animal() . a.talk() . Animal talk . (None, 1.0045440196990967) . Also, all classes inheriting from classes thus created, will also have the same metaclass . class Cow(Animal): def talk(self): time.sleep(1) print(&quot;Moo&quot;) . print(Animal.__class__) . &lt;class &#39;__main__.TimeMeta&#39;&gt; . c = Cow() . c.talk() . Moo . (None, 1.005091667175293) . References . 1. Python: Meta-Programming↩ . 2. Great answer from StackOverflow↩ . 3. Python Metaclasses↩ .",
            "url": "https://juan-carlos-calvo.github.io/blog/python/2020/03/29/metaclasses.html",
            "relUrl": "/python/2020/03/29/metaclasses.html",
            "date": " • Mar 29, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Fastcore 00",
            "content": "This is the first of a series of posts Fastcore # whose aim is just for me to go through the development of the fastcore library to understand it. . from fastcore.imports import * . Test . Helper functions to quickly write tests in notebooks . Simple test functions . We can check that code raises an exception when that&#39;s expected (test_fail). To test for equality or inequality (with different types of things) we define a simple function test that compares two object with a given cmp operator. . def test_fail(f, msg=&#39;&#39;, contains=&#39;&#39;): &quot;Fails with `msg` unless `f()` raises an exception and (optionally) has `contains` in `e.args`&quot; try: f() except Exception as e: assert not contains or contains in str(e) return assert False,f&quot;Expected exception but none raised. {msg}&quot; . def _fail(): raise Exception(&quot;foobar&quot;) test_fail(_fail, contains=&quot;foo&quot;) def _fail(): raise Exception() test_fail(_fail) . def test(a, b, cmp,cname=None): &quot;`assert` that `cmp(a,b)`; display inputs and `cname or cmp.__name__` if it fails&quot; if cname is None: cname=cmp.__name__ assert cmp(a,b),f&quot;{cname}: n{a} n{b}&quot; . test([1,2],[1,2], operator.eq) test_fail(lambda: test([1,2],[1], operator.eq)) test([1,2],[1], operator.ne) test_fail(lambda: test([1,2],[1,2], operator.ne)) . test([&#39;abc&#39;], [&#39;abc&#39;], all_equal) . test([[&#39;abc&#39;],[&#39;a&#39;]], [[&#39;abc&#39;],[&#39;a&#39;]], equals) . def nequals(a,b): &quot;Compares `a` and `b` for `not equals`&quot; return not equals(a,b) . test([&#39;abc&#39;], [&#39;ab&#39; ], nequals) . test_eq test_ne, etc... . Just use test_eq/test_ne to test for ==/!=. test_eq_type check things are equals and of the same type. We define them using test: . def test_eq(a,b): &quot;`test` that `a==b`&quot; test(a,b,equals, &#39;==&#39;) . test_eq([1,2],[1,2]) test_eq([1,2],map(int,[1,2])) test_eq(array([1,2]),array([1,2])) test_eq(array([1,2]),array([1,2])) test_eq([array([1,2]),3],[array([1,2]),3]) test_eq(dict(a=1,b=2), dict(b=2,a=1)) test_fail(lambda: test_eq([1,2], 1), contains=&quot;==&quot;) test_eq({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}, {&#39;c&#39;, &#39;a&#39;, &#39;b&#39;}) . df1 = pd.DataFrame(dict(a=[1,2],b=[&#39;a&#39;,&#39;b&#39;])) df2 = pd.DataFrame(dict(a=[1,2],b=[&#39;a&#39;,&#39;b&#39;])) test_eq(df1,df2) test_eq(df1.a,df2.a) class T(pd.Series): pass test_eq(df1.iloc[0], T(df2.iloc[0])) . def test_eq_type(a,b): &quot;`test` that `a==b` and are same type&quot; test_eq(a,b) test_eq(type(a),type(b)) if isinstance(a,(list,tuple)): test_eq(map(type,a),map(type,b)) . test_eq_type(1,1) test_fail(lambda: test_eq_type(1,1.)) test_eq_type([1,1],[1,1]) test_fail(lambda: test_eq_type([1,1],(1,1))) test_fail(lambda: test_eq_type([1,1],[1,1.])) . def test_ne(a,b): &quot;`test` that `a!=b`&quot; test(a,b,nequals,&#39;!=&#39;) . test_ne([1,2],[1]) test_ne([1,2],[1,3]) test_ne(array([1,2]),array([1,1])) test_ne(array([1,2]),array([1,1])) test_ne([array([1,2]),3],[array([1,2])]) test_ne([3,4],array([3])) test_ne([3,4],array([3,5])) test_ne(dict(a=1,b=2), [&#39;a&#39;, &#39;b&#39;]) test_ne([&#39;a&#39;, &#39;b&#39;], dict(a=1,b=2)) . def is_close(a,b,eps=1e-5): &quot;Is `a` within `eps` of `b`&quot; if hasattr(a, &#39;__array__&#39;) or hasattr(b,&#39;__array__&#39;): return (abs(a-b)&lt;eps).all() if isinstance(a, (Iterable,Generator)) or isinstance(b, (Iterable,Generator)): return is_close(np.array(a), np.array(b), eps=eps) return abs(a-b)&lt;eps . def test_close(a,b,eps=1e-5): &quot;`test` that `a` is within `eps` of `b`&quot; test(a,b,partial(is_close,eps=eps),&#39;close&#39;) . test_close(1,1.001,eps=1e-2) test_fail(lambda: test_close(1,1.001)) test_close([-0.001,1.001], [0.,1.], eps=1e-2) test_close(np.array([-0.001,1.001]), np.array([0.,1.]), eps=1e-2) test_close(array([-0.001,1.001]), array([0.,1.]), eps=1e-2) . def test_is(a,b): &quot;`test` that `a is b`&quot; test(a,b,operator.is_, &#39;is&#39;) . test_fail(lambda: test_is([1], [1])) a = [1] test_is(a, a) . def test_shuffled(a,b): &quot;`test` that `a` and `b` are shuffled versions of the same sequence of items&quot; test_ne(a, b) test_eq(Counter(a), Counter(b)) . a = list(range(50)) b = copy(a) random.shuffle(b) test_shuffled(a,b) test_fail(lambda:test_shuffled(a,a)) . a = &#39;abc&#39; b = &#39;abcabc&#39; test_fail(lambda:test_shuffled(a,b)) . a = [&#39;a&#39;, 42, True] b = [42, True, &#39;a&#39;] test_shuffled(a,b) . def test_stdout(f, exp, regex=False): &quot;Test that `f` prints `exp` to stdout, optionally checking as `regex`&quot; s = io.StringIO() with redirect_stdout(s): f() if regex: assert re.search(exp, s.getvalue()) is not None else: test_eq(s.getvalue(), f&#39;{exp} n&#39; if len(exp) &gt; 0 else &#39;&#39;) . test_stdout(lambda: print(&#39;hi&#39;), &#39;hi&#39;) test_fail(lambda: test_stdout(lambda: print(&#39;hi&#39;), &#39;ho&#39;)) test_stdout(lambda: 1+1, &#39;&#39;) test_stdout(lambda: print(&#39;hi there!&#39;), r&#39;^hi.*!$&#39;, regex=True) . def test_warns(f, show=False): with warnings.catch_warnings(record=True) as w: f() test_ne(len(w), 0) if show: for e in w: print(f&quot;{e.category}: {e.message}&quot;) . test_warns(lambda: warnings.warn(&quot;Oh no!&quot;), {}) test_fail(lambda: test_warns(lambda: 2+2)) . test_warns(lambda: warnings.warn(&quot;Oh no!&quot;), show=True) . &lt;class &#39;UserWarning&#39;&gt;: Oh no! . TEST_IMAGE = &#39;my_icons/puppy.jpg&#39; . im = Image.open(TEST_IMAGE).resize((128,128)); im . TEST_IMAGE_BW = &#39;my_icons/mnist3.png&#39; . im = Image.open(TEST_IMAGE_BW).resize((128,128)); im . def test_fig_exists(ax): &quot;Test there is a figure displayed in `ax`&quot; assert ax and len(np.frombuffer(ax.figure.canvas.tostring_argb(), dtype=np.uint8)) . fig,ax = plt.subplots() ax.imshow(array(im)); . test_fig_exists(ax) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/03/28/test-fastcore.html",
            "relUrl": "/fastcore/fastai/python/2020/03/28/test-fastcore.html",
            "date": " • Mar 28, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Cool gifs",
            "content": ". . There was a &#39;Not Found&#39; error fetching URL: &#39;https://twitter.com/universal_sci/status/1225605832949293056?s=20&#39; . .",
            "url": "https://juan-carlos-calvo.github.io/blog/gifs/twitter/2020/03/26/cool-gifs-1.html",
            "relUrl": "/gifs/twitter/2020/03/26/cool-gifs-1.html",
            "date": " • Mar 26, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "masks4all",
            "content": "The Czech Republic went from zero mask usage to 100% in 10 days, and in the process they halted the growth of new covid-19 cases.How? They made their own! They didn&#39;t need government help; they did it themselves.It&#39;s time for #masks4all. See why:https://t.co/SiYApRvByq1/ . &mdash; Jeremy #Masks4All Howard (@jeremyphoward) March 25, 2020 .",
            "url": "https://juan-carlos-calvo.github.io/blog/twitter/2020/03/25/masks4all.html",
            "relUrl": "/twitter/2020/03/25/masks4all.html",
            "date": " • Mar 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://juan-carlos-calvo.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://juan-carlos-calvo.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}