{
  
    
        "post0": {
            "title": "Fastcore 01",
            "content": "This is the second of a series of posts whose aim is to go through the complete development of fastcore and fastai2. See this post for a brief overview of metaclasses and references thereof. . from fastcore.imports import * . Core . Basic functions used in the fastai library . defaults = SimpleNamespace() . Metaclasses . Actually I&#39;m not sure FixSigMeta does anything for now, because if I don´t fix the signature and inherit from a metaclass (which doesn´t overwrite __init__), the signature stays the same. . class FixSigMeta(type): &quot;A metaclass that fixes the signature on classes that override __init__&quot; def __new__(cls, name, bases, dict): res = super().__new__(cls, name, bases, dict) if res.__init__ is not object.__init__: res.__signature__ = inspect.signature(res.__init__) return res . I&#39;m curious about when type(cls.__new__(cls))!=cls. Note that cls is the class inheriting from this metaclass. . class PrePostInitMeta(FixSigMeta): &quot;A metaclass that calls optional `__pre_init__` and `__post_init__` methods&quot; def __call__(cls, *args, **kwargs): res = cls.__new__(cls) if type(res)==cls: if hasattr(res,&#39;__pre_init__&#39;): res.__pre_init__(*args,**kwargs) res.__init__(*args,**kwargs) if hasattr(res,&#39;__post_init__&#39;): res.__post_init__(*args,**kwargs) return res . Here is a simple test . class _T(metaclass=PrePostInitMeta): def __pre_init__(self): self.a = 0; assert self.a==0 def __init__(self,b=0): self.a += 1; assert self.a==1 def __post_init__(self): self.a += 1; assert self.a==2 t = _T() test_eq(t.a, 2) . The metaclass below avoids recreating x when x is passed as the sole argument to cls if x is an instance of cls (x.__class__=cls or equivalently isinstance(x, cls)==True). It also adds the property _newchk to x which tracks if x has been passed as the sole argument to its class (x._newchk=1) or not (x._newchk=0). . class NewChkMeta(FixSigMeta): &quot;Metaclass to avoid recreating object passed to constructor&quot; def __call__(cls, x=None, *args, **kwargs): if not args and not kwargs and x is not None and isinstance(x,cls): x._newchk = 1 return x res = super().__call__(*((x,) + args), **kwargs) res._newchk = 0 return res . class _T(metaclass=NewChkMeta): &quot;Testing&quot; def __init__(self, o=None, b=1): self.foo = getattr(o,&#39;foo&#39;,0) + 1 self.b = b . class _T2(): def __init__(self, o): self.foo = getattr(o,&#39;foo&#39;,0) + 1 . Below, t is passed as the sole argument to _T and thus, because of its metaclass, it is returned as it is and no new object is created . t = _T(1) test_eq(t.foo,1) t2 = _T(t) test_eq(t2.foo,1) test_is(t,t2) . Below, t is passed not as the sole argument, so a new object t3 different from t is created . t3 = _T(t, b=2) test_eq(t3.b, 2) assert not t3 is t . Observe that t2 is different from t unlike above (_T2 doesn&#39;t inherits from the metaclass). . t = _T2(1) test_eq(t.foo,1) t2 = _T2(t) test_eq(t2.foo,2) test_eq(_T.__doc__, &quot;Testing&quot;) # TODO: this shouldn&#39;t have &quot;self, &quot; test_eq(str(inspect.signature(_T)), &#39;(self, o=None, b=1)&#39;) . If cls has the attribute _bypass_type, and x is of this type (and is the sole, x argument, its type will by fixed to cls. Furthermore, if cls has the method _new_meta, x will by initialized by it. . class BypassNewMeta(FixSigMeta): &quot;Metaclass: casts `x` to this class if it&#39;s of type `cls._bypass_type`, initializing with `_new_meta` if available&quot; def __call__(cls, x=None, *args, **kwargs): if hasattr(cls, &#39;_new_meta&#39;): x = cls._new_meta(x, *args, **kwargs) elif not isinstance(x,getattr(cls,&#39;_bypass_type&#39;,object)) or len(args) or len(kwargs): x = super().__call__(*((x,)+args), **kwargs) if cls!=x.__class__: x.__class__ = cls return x . class T0: pass class _T(T0, metaclass=BypassNewMeta): _bypass_type=T0 def __init__(self,x): self.x=x t = T0() t.a = 1 t2 = _T(t) test_eq(type(t2), _T) test_eq(t2.a,1) test_is(t2,t) t = _T(2) t.x = 2 . Foundational functions . copy.copy doesn´t work to copy functions, so we have to create a new one with all the same attributes. . def copy_func(f): &quot;Copy a non-builtin function (NB `copy.copy` does not work for this)&quot; if not isinstance(f,FunctionType): return copy(f) fn = FunctionType(f.__code__, f.__globals__, f.__name__, f.__defaults__, f.__closure__) fn.__dict__.update(f.__dict__) return fn . Function wrapper that adds f to cls which can be either a class or a tuple/list of classes. If as_prop==True, f is added as property. . def patch_to(cls, as_prop=False): &quot;Decorator: add `f` to `cls`&quot; if not isinstance(cls, (tuple,list)): cls=(cls,) def _inner(f): for c_ in cls: nf = copy_func(f) # `functools.update_wrapper` when passing patched function to `Pipeline`, so we do it manually for o in functools.WRAPPER_ASSIGNMENTS: setattr(nf, o, getattr(f,o)) nf.__qualname__ = f&quot;{c_.__name__}.{f.__name__}&quot; setattr(c_, f.__name__, property(nf) if as_prop else nf) return f return _inner . class _T3(int): pass @patch_to(_T3) def func1(x, a): return x+a t = _T3(1) test_eq(t.func1(2), 3) . class _T4(int): pass @patch_to((_T3,_T4)) def func2(x, a): return x+2*a t = _T3(1) test_eq(t.func2(1), 3) t = _T4(1) test_eq(t.func2(1), 3) . By reading fs type annotations, this decorator add&#39;s f to the type of f&#39;s first argument. . def patch(f): &quot;Decorator: add `f` to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls)(f) . @patch def func(x:_T3, a): &quot;test&quot; return x+2 t = _T3(1) test_eq(t.func(2), 3) test_eq(t.func.__qualname__, &#39;_T3.func&#39;) . @patch def func3(x:(_T3,_T4), a): &quot;test&quot; return x+2*a t = _T3(1) test_eq(t.func3(2), 5) test_eq(t.func3.__qualname__, &#39;_T3.func3&#39;) t = _T4(1) test_eq(t.func3(2), 5) test_eq(t.func3.__qualname__, &#39;_T4.func3&#39;) . Same as above, but with as_prop==True. . def patch_property(f): &quot;Decorator: add `f` as a property to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls, as_prop=True)(f) . @patch_property def prop(x:_T3): return x+1 t = _T3(1) test_eq(t.prop, 2) . Create paramter named n with value d . def _mk_param(n,d=None): return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d) . Test that fs signature is b. . def test_sig(f, b): test_eq(str(inspect.signature(f)), b) . replace (if keep=False, otherwise add to) f&#39;s signature **kwargs with the descorator&#39;s **kwargs . def use_kwargs_dict(keep=False, **kwargs): &quot;Decorator: replace `**kwargs` in signature with `names` params&quot; def _f(f): sig = inspect.signature(f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . * specifies the end of regular arguments and the start of keyword arguments . @use_kwargs_dict(y=1,z=None) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, *, y=1, z=None)&#39;) . def use_kwargs(names, keep=False): &quot;Decorator: replace `**kwargs` in signature with `names` params&quot; def _f(f): sig = inspect.signature(f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {n:_mk_param(n) for n in names if n not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . @use_kwargs([&#39;y&#39;, &#39;z&#39;]) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, *, y=None, z=None)&#39;) @use_kwargs([&#39;y&#39;, &#39;z&#39;], keep=True) def foo(a, *args, b=1, **kwargs): pass test_sig(foo, &#39;(a, *args, b=1, y=None, z=None, **kwargs)&#39;) . def delegates(to=None, keep=False): &quot;Decorator: replace `**kwargs` in signature with params from `to`&quot; def _f(f): if to is None: to_f,from_f = f.__base__.__init__,f.__init__ else: to_f,from_f = to,f from_f = getattr(from_f,&#39;__func__&#39;,from_f) if hasattr(from_f,&#39;__delwrap__&#39;): return f sig = inspect.signature(from_f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {k:v for k,v in inspect.signature(to_f).parameters.items() if v.default != inspect.Parameter.empty and k not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k else: from_f.__delwrap__ = to_f from_f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . def basefoo(e, c=2): pass @delegates(basefoo) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, c=2)&#39;) @delegates(basefoo, keep=True) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, c=2, **kwargs)&#39;) . class BaseFoo: def __init__(self, e, c=2): pass @delegates() class Foo(BaseFoo): def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs) test_sig(Foo, &#39;(a, b=1, c=2)&#39;) . def funcs_kwargs(cls): &quot;Replace methods in `self._methods` with those from `kwargs`&quot; old_init = cls.__init__ def _init(self, *args, **kwargs): for k in cls._methods: arg = kwargs.pop(k,None) if arg is not None: if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self) setattr(self, k, arg) old_init(self, *args, **kwargs) functools.update_wrapper(_init, old_init) cls.__init__ = use_kwargs(cls._methods)(_init) return cls . def method(f): &quot;Mark `f` as a method&quot; # `1` is a dummy instance since Py3 doesn&#39;t allow `None` any more return MethodType(f, 1) . @funcs_kwargs class T: _methods=[&#39;b&#39;] def __init__(self, f=1, **kwargs): assert not kwargs def a(self): return 1 def b(self): return 2 t = T() test_eq(t.a(), 1) test_eq(t.b(), 2) t = T(b = lambda:3) test_eq(t.b(), 3) test_sig(T, &#39;(f=1, *, b=None)&#39;) test_fail(lambda: T(a = lambda:3)) @method def _f(self,a=1): return a+1 t = T(b = _f) test_eq(t.b(2), 3) class T2(T): def __init__(self,a): super().__init__(b = lambda:3) self.a=a t = T2(a=1) test_eq(t.b(), 3) test_sig(T2, &#39;(a)&#39;) def _g(a=1): return a+1 class T3(T): b = staticmethod(_g) t = T3() test_eq(t.b(2), 3) . @contextmanager def working_directory(path): &quot;Change working directory to `path` and return to previous on exit.&quot; prev_cwd = Path.cwd() os.chdir(path) try: yield finally: os.chdir(prev_cwd) . def add_docs(cls, cls_doc=None, **docs): &quot;Copy values from `docs` to `cls` docstrings, and confirm all public methods are documented&quot; if cls_doc is not None: cls.__doc__ = cls_doc for k,v in docs.items(): f = getattr(cls,k) if hasattr(f,&#39;__func__&#39;): f = f.__func__ # required for class methods f.__doc__ = v # List of public callables without docstring nodoc = [c for n,c in vars(cls).items() if callable(c) and not n.startswith(&#39;_&#39;) and c.__doc__ is None] assert not nodoc, f&quot;Missing docs: {nodoc}&quot; assert cls.__doc__ is not None, f&quot;Missing class docs: {cls}&quot; . def docs(cls): &quot;Decorator version of `add_docs`, using `_docs` dict&quot; add_docs(cls, **cls._docs) return cls . class _T: def f(self): pass @classmethod def g(cls): pass add_docs(_T, &quot;a&quot;, f=&quot;f&quot;, g=&quot;g&quot;) test_eq(_T.__doc__, &quot;a&quot;) test_eq(_T.f.__doc__, &quot;f&quot;) test_eq(_T.g.__doc__, &quot;g&quot;) . def custom_dir(c, add:list): &quot;Implement custom `__dir__`, adding `add` to `cls`&quot; return dir(type(c)) + list(c.__dict__.keys()) + addb . class _Arg: def __init__(self,i): self.i = i arg0 = _Arg(0) arg1 = _Arg(1) arg2 = _Arg(2) arg3 = _Arg(3) arg4 = _Arg(4) . class bind: &quot;Same as `partial`, except you can use `arg0` `arg1` etc param placeholders&quot; def __init__(self, fn, *pargs, **pkwargs): self.fn,self.pargs,self.pkwargs = fn,pargs,pkwargs self.maxi = max((x.i for x in pargs if isinstance(x, _Arg)), default=-1) def __call__(self, *args, **kwargs): args = list(args) kwargs = {**self.pkwargs,**kwargs} for k,v in kwargs.items(): if isinstance(v,_Arg): kwargs[k] = args.pop(v.i) fargs = [args[x.i] if isinstance(x, _Arg) else x for x in self.pargs] + args[self.maxi+1:] return self.fn(*fargs, **kwargs) . def myfn(a,b,c,d=1,e=2): return(a,b,c,d,e) test_eq(bind(myfn, arg1, 17, arg0, e=3)(19,14), (14,17,19,1,3)) test_eq(bind(myfn, 17, arg0, e=3)(19,14), (17,19,14,1,3)) test_eq(bind(myfn, 17, e=3)(19,14), (17,19,14,1,3)) test_eq(bind(myfn)(17,19,14), (17,19,14,1,2)) test_eq(bind(myfn, 17,19,14,e=arg0)(3), (17,19,14,1,3)) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/06/03/fastcore-foundations-1-Copy1.html",
            "relUrl": "/fastcore/fastai/python/2020/06/03/fastcore-foundations-1-Copy1.html",
            "date": " • Jun 3, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastcore 01",
            "content": "This is the second of a series of posts whose aim is to go through the complete development of fastcore and fastai2. See this post for a brief overview of metaclasses and references thereof. . from fastcore.imports import * . Core . Basic functions used in the fastai library . Metaclasses . Actually I&#39;m not sure FixSigMeta does anything for now, because if I don´t fix the signature and inherit from a metaclass (which doesn´t overwrite __init__), the signature stays the same. . class FixSigMeta(type): &quot;A metaclass that fixes the signature on classes that override __init__&quot; def __new__(cls, name, bases, dict): res = super().__new__(cls, name, bases, dict) if res.__init__ is not object.__init__: res.__signature__ = inspect.signature(res.__init__) return res . I&#39;m curious about when type(cls.__new__(cls))!=cls. Note that cls is the class inheriting from this metaclass. . class PrePostInitMeta(FixSigMeta): &quot;A metaclass that calls optional `__pre_init__` and `__post_init__` methods&quot; def __call__(cls, *args, **kwargs): res = cls.__new__(cls) if type(res)==cls: if hasattr(res,&#39;__pre_init__&#39;): res.__pre_init__(*args,**kwargs) res.__init__(*args,**kwargs) if hasattr(res,&#39;__post_init__&#39;): res.__post_init__(*args,**kwargs) return res . Here is a simple test . class _T(metaclass=PrePostInitMeta): def __pre_init__(self): self.a = 0; assert self.a==0 def __init__(self,b=0): self.a += 1; assert self.a==1 def __post_init__(self): self.a += 1; assert self.a==2 t = _T() test_eq(t.a, 2) . The metaclass below avoids recreating x when x is passed as the sole argument to cls if x is an instance of cls (x.__class__=cls or equivalently isinstance(x, cls)==True). It also adds the property _newchk to x which tracks if x has been passed as the sole argument to its class (x._newchk=1) or not (x._newchk=0). . class NewChkMeta(FixSigMeta): &quot;Metaclass to avoid recreating object passed to constructor&quot; def __call__(cls, x=None, *args, **kwargs): if not args and not kwargs and x is not None and isinstance(x,cls): x._newchk = 1 return x res = super().__call__(*((x,) + args), **kwargs) res._newchk = 0 return res . class _T(metaclass=NewChkMeta): &quot;Testing&quot; def __init__(self, o=None, b=1): self.foo = getattr(o,&#39;foo&#39;,0) + 1 self.b = b . class _T2(): def __init__(self, o): self.foo = getattr(o,&#39;foo&#39;,0) + 1 . Below, t is passed as the sole argument to _T and thus, because of its metaclass, it is returned as it is and no new object is created . t = _T(1) test_eq(t.foo,1) t2 = _T(t) test_eq(t2.foo,1) test_is(t,t2) . Below, t is passed not as the sole argument, so a new object t3 different from t is created . t3 = _T(t, b=2) test_eq(t3.b, 2) assert not t3 is t . Observe that t2 is different from t unlike above (_T2 doesn&#39;t inherits from the metaclass). . t = _T2(1) test_eq(t.foo,1) t2 = _T2(t) test_eq(t2.foo,2) test_eq(_T.__doc__, &quot;Testing&quot;) # TODO: this shouldn&#39;t have &quot;self, &quot; test_eq(str(inspect.signature(_T)), &#39;(self, o=None, b=1)&#39;) . If cls has the attribute _bypass_type, and x is of this type (and is the sole, x argument, its type will by fixed to cls. Furthermore, if cls has the method _new_meta, x will by initialized by it. . class BypassNewMeta(FixSigMeta): &quot;Metaclass: casts `x` to this class if it&#39;s of type `cls._bypass_type`, initializing with `_new_meta` if available&quot; def __call__(cls, x=None, *args, **kwargs): if hasattr(cls, &#39;_new_meta&#39;): x = cls._new_meta(x, *args, **kwargs) elif not isinstance(x,getattr(cls,&#39;_bypass_type&#39;,object)) or len(args) or len(kwargs): x = super().__call__(*((x,)+args), **kwargs) if cls!=x.__class__: x.__class__ = cls return x . class T0: pass class _T(T0, metaclass=BypassNewMeta): _bypass_type=T0 def __init__(self,x): self.x=x t = T0() t.a = 1 t2 = _T(t) test_eq(type(t2), _T) test_eq(t2.a,1) test_is(t2,t) t = _T(2) t.x = 2 . Foundational functions . copy.copy doesn´t work to copy functions, so we have to create a new one with all the same attributes. . def copy_func(f): &quot;Copy a non-builtin function (NB `copy.copy` does not work for this)&quot; if not isinstance(f,FunctionType): return copy(f) fn = FunctionType(f.__code__, f.__globals__, f.__name__, f.__defaults__, f.__closure__) fn.__dict__.update(f.__dict__) return fn . Function wrapper that adds f to cls which can be either a class or a tuple/list of classes. If as_prop==True, f is added as property. . def patch_to(cls, as_prop=False): &quot;Decorator: add `f` to `cls`&quot; if not isinstance(cls, (tuple,list)): cls=(cls,) def _inner(f): for c_ in cls: nf = copy_func(f) # `functools.update_wrapper` when passing patched function to `Pipeline`, so we do it manually for o in functools.WRAPPER_ASSIGNMENTS: setattr(nf, o, getattr(f,o)) nf.__qualname__ = f&quot;{c_.__name__}.{f.__name__}&quot; setattr(c_, f.__name__, property(nf) if as_prop else nf) return f return _inner . class _T3(int): pass @patch_to(_T3) def func1(x, a): return x+a t = _T3(1) test_eq(t.func1(2), 3) . class _T4(int): pass @patch_to((_T3,_T4)) def func2(x, a): return x+2*a t = _T3(1) test_eq(t.func2(1), 3) t = _T4(1) test_eq(t.func2(1), 3) . By reading fs type annotations, this decorator add&#39;s f to the type of f&#39;s first argument. . def patch(f): &quot;Decorator: add `f` to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls)(f) . @patch def func(x:_T3, a): &quot;test&quot; return x+2 t = _T3(1) test_eq(t.func(2), 3) test_eq(t.func.__qualname__, &#39;_T3.func&#39;) . @patch def func3(x:(_T3,_T4), a): &quot;test&quot; return x+2*a t = _T3(1) test_eq(t.func3(2), 5) test_eq(t.func3.__qualname__, &#39;_T3.func3&#39;) t = _T4(1) test_eq(t.func3(2), 5) test_eq(t.func3.__qualname__, &#39;_T4.func3&#39;) . Same as above, but with as_prop==True. . def patch_property(f): &quot;Decorator: add `f` as a property to the first parameter&#39;s class (based on f&#39;s type annotations)&quot; cls = next(iter(f.__annotations__.values())) return patch_to(cls, as_prop=True)(f) . @patch_property def prop(x:_T3): return x+1 t = _T3(1) test_eq(t.prop, 2) . Create paramter named n with value d . def _mk_param(n,d=None): return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d) . Test that fs signature is b. . def test_sig(f, b): test_eq(str(inspect.signature(f)), b) . replace (if keep=False, otherwise add to) f&#39;s signature **kwargs with the descorator&#39;s **kwargs . def use_kwargs_dict(keep=False, **kwargs): &quot;Decorator: replace `**kwargs` in signature with `names` params&quot; def _f(f): sig = inspect.signature(f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . * specifies the end of regular arguments and the start of keyword arguments . @use_kwargs_dict(y=1,z=None) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, *, y=1, z=None)&#39;) . Same as use_kwargs_dict but adds arguments with keys names and values None. . def use_kwargs(names, keep=False): &quot;Decorator: replace `**kwargs` in signature with `names` params&quot; def _f(f): sig = inspect.signature(f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {n:_mk_param(n) for n in names if n not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . @use_kwargs([&#39;y&#39;, &#39;z&#39;]) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, *, y=None, z=None)&#39;) @use_kwargs([&#39;y&#39;, &#39;z&#39;], keep=True) def foo(a, *args, b=1, **kwargs): pass test_sig(foo, &#39;(a, *args, b=1, y=None, z=None, **kwargs)&#39;) . Here if to is None, f is assumed to be a class and it replaces (if keep==False) the kwargs of its __init__ with the named params of its base class. . def delegates(to=None, keep=False): &quot;Decorator: replace `**kwargs` in signature with params from `to`&quot; def _f(f): if to is None: to_f,from_f = f.__base__.__init__,f.__init__ else: to_f,from_f = to,f from_f = getattr(from_f,&#39;__func__&#39;,from_f) if hasattr(from_f,&#39;__delwrap__&#39;): return f sig = inspect.signature(from_f) sigd = dict(sig.parameters) k = sigd.pop(&#39;kwargs&#39;) s2 = {k:v for k,v in inspect.signature(to_f).parameters.items() if v.default != inspect.Parameter.empty and k not in sigd} sigd.update(s2) if keep: sigd[&#39;kwargs&#39;] = k else: from_f.__delwrap__ = to_f from_f.__signature__ = sig.replace(parameters=sigd.values()) return f return _f . def basefoo(e, c=2): pass @delegates(basefoo) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, c=2)&#39;) @delegates(basefoo, keep=True) def foo(a, b=1, **kwargs): pass test_sig(foo, &#39;(a, b=1, c=2, **kwargs)&#39;) . class BaseFoo: def __init__(self, e, c=2): pass @delegates() class Foo(BaseFoo): def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs) test_sig(Foo, &#39;(a, b=1, c=2)&#39;) . Replace cls._methods by those in **kwargs. If one of them is of type MethodType it&#39;s object is changed to self. Also, the signature of __init__ is updated. . def funcs_kwargs(cls): &quot;Replace methods in `self._methods` with those from `kwargs`&quot; old_init = cls.__init__ def _init(self, *args, **kwargs): for k in cls._methods: arg = kwargs.pop(k,None) if arg is not None: if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self) setattr(self, k, arg) old_init(self, *args, **kwargs) functools.update_wrapper(_init, old_init) cls.__init__ = use_kwargs(cls._methods)(_init) return cls . def method(f): &quot;Mark `f` as a method&quot; # `1` is a dummy instance since Py3 doesn&#39;t allow `None` any more return MethodType(f, 1) . @funcs_kwargs class T: _methods=[&#39;b&#39;] def __init__(self, f=1, **kwargs): assert not kwargs def a(self): return 1 def b(self): return 2 t = T() test_eq(t.a(), 1) test_eq(t.b(), 2) t = T(b = lambda:3) test_eq(t.b(), 3) test_sig(T, &#39;(f=1, *, b=None)&#39;) test_fail(lambda: T(a = lambda:3)) @method def _f(self,a=1): return a+1 t = T(b = _f) test_eq(t.b(2), 3) class T2(T): def __init__(self,a): super().__init__(b = lambda:3) self.a=a t = T2(a=1) test_eq(t.b(), 3) test_sig(T2, &#39;(a)&#39;) def _g(a=1): return a+1 class T3(T): b = staticmethod(_g) t = T3() test_eq(t.b(2), 3) . This creates a context manager pretty much like with open(...) as heendle: where everything before the yield is excecuted before the block under with, then that block is excecuted, and finally, everything after yield. . @contextmanager def working_directory(path): &quot;Change working directory to `path` and return to previous on exit.&quot; prev_cwd = Path.cwd() os.chdir(path) try: yield finally: os.chdir(prev_cwd) . Add docstrings from arguments. . def add_docs(cls, cls_doc=None, **docs): &quot;Copy values from `docs` to `cls` docstrings, and confirm all public methods are documented&quot; if cls_doc is not None: cls.__doc__ = cls_doc for k,v in docs.items(): f = getattr(cls,k) if hasattr(f,&#39;__func__&#39;): f = f.__func__ # required for class methods f.__doc__ = v # List of public callables without docstring nodoc = [c for n,c in vars(cls).items() if callable(c) and not n.startswith(&#39;_&#39;) and c.__doc__ is None] assert not nodoc, f&quot;Missing docs: {nodoc}&quot; assert cls.__doc__ is not None, f&quot;Missing class docs: {cls}&quot; . def docs(cls): &quot;Decorator version of `add_docs`, using `_docs` dict&quot; add_docs(cls, **cls._docs) return cls . class _T: def f(self): pass @classmethod def g(cls): pass add_docs(_T, &quot;a&quot;, f=&quot;f&quot;, g=&quot;g&quot;) test_eq(_T.__doc__, &quot;a&quot;) test_eq(_T.f.__doc__, &quot;f&quot;) test_eq(_T.g.__doc__, &quot;g&quot;) . Below is an implementation of partial which allows you to specify the arguments being partially evaluated through _Arg instances. . class _Arg: def __init__(self,i): self.i = i arg0 = _Arg(0) arg1 = _Arg(1) arg2 = _Arg(2) arg3 = _Arg(3) arg4 = _Arg(4) . class bind: &quot;Same as `partial`, except you can use `arg0` `arg1` etc param placeholders&quot; def __init__(self, fn, *pargs, **pkwargs): self.fn,self.pargs,self.pkwargs = fn,pargs,pkwargs self.maxi = max((x.i for x in pargs if isinstance(x, _Arg)), default=-1) def __call__(self, *args, **kwargs): args = list(args) kwargs = {**self.pkwargs,**kwargs} for k,v in kwargs.items(): if isinstance(v,_Arg): kwargs[k] = args.pop(v.i) fargs = [args[x.i] if isinstance(x, _Arg) else x for x in self.pargs] + args[self.maxi+1:] return self.fn(*fargs, **kwargs) . def myfn(a,b,c,d=1,e=2): return(a,b,c,d,e) test_eq(bind(myfn, arg1, 17, arg0, e=3)(19,14), (14,17,19,1,3)) test_eq(bind(myfn, 17, arg0, e=3)(19,14), (17,19,14,1,3)) test_eq(bind(myfn, 17, e=3)(19,14), (17,19,14,1,3)) test_eq(bind(myfn)(17,19,14), (17,19,14,1,2)) test_eq(bind(myfn, 17,19,14,e=arg0)(3), (17,19,14,1,3)) . def custom_dir(c, add:list): &quot;Implement custom `__dir__`, adding `add` to `cls`&quot; return dir(type(c)) + list(c.__dict__.keys()) + add . if self._xtra is None, all attributes of self.default are passed to self. If self._xtra is not None, only those in self._xtra are passed along. . class GetAttr: &quot;Inherit from this to have all attr accesses in `self._xtra` passed down to `self.default`&quot; _default=&#39;default&#39; def _component_attr_filter(self,k): if k.startswith(&#39;__&#39;) or k in (&#39;_xtra&#39;,self._default): return False xtra = getattr(self,&#39;_xtra&#39;,None) return xtra is None or k in xtra def _dir(self): return [k for k in dir(getattr(self,self._default)) if self._component_attr_filter(k)] def __getattr__(self,k): if self._component_attr_filter(k): attr = getattr(self,self._default,None) if attr is not None: return getattr(attr,k) raise AttributeError(k) def __dir__(self): return custom_dir(self,self._dir()) # def __getstate__(self): return self.__dict__ def __setstate__(self,data): self.__dict__.update(data) . Inherit from GetAttr to have attr access passed down to an instance attribute. This makes it easy to create composites that don&#39;t require callers to know about their components. . You can customise the behaviour of GetAttr in subclasses via; . _default By default, this is set to &#39;default&#39;, so attr access is passed down to self.default | _default can be set to the name of any instance attribute that does not start with dunder __ | . | _xtra By default, this is None, so all attr access is passed down | You can limit which attrs get passed down by setting _xtra to a list of attribute names | . | . class _C(GetAttr): # allow all attributes to get passed to `self.default` (by leaving _xtra=None) def __init__(self,a): self.default = a def foo(self): noop t = _C(&#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_eq(t.upper(), &#39;HI&#39;) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; in dir(t) . class _C(GetAttr): _xtra = [&#39;lower&#39;] # specify which attributes get passed to `self.default` def __init__(self,a): self.default = a def foo(self): noop . t = _C(&#39;Hi&#39;) test_eq(t.default, &#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_fail(lambda: t.upper()) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; not in dir(t) . class _C(GetAttr): _default = &#39;_data&#39; # use different component name; `self._data` rather than `self.default` def __init__(self,a): self._data = a def foo(self): noop . t = _C(&#39;Hi&#39;) test_eq(t._data, &#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_eq(t.upper(), &#39;HI&#39;) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; in dir(t) . class _C(GetAttr): _default = &#39;data&#39; # use a bad component name; i.e. self.data does not exist def __init__(self,a): self.default = a def foo(self): noop # TODO: should we raise an error when we create a new instance ... t = _C(&#39;Hi&#39;) test_eq(t.default, &#39;Hi&#39;) # ... or is it enough for all GetAttr features to raise errors test_fail(lambda: t.data) test_fail(lambda: t.lower()) test_fail(lambda: t.upper()) test_fail(lambda: dir(t)) . class _C(GetAttr): _xtra = [&#39;lower&#39;, &#39;upper&#39;] _default = &#39;data&#39; def __init__(self,a): self.data = a def foo(self): noop t = _C(&#39;Hi&#39;) test_eq(t.data, &#39;Hi&#39;) test_eq(t.lower(), &#39;hi&#39;) test_eq(t.upper(), &#39;HI&#39;) assert &#39;lower&#39; in dir(t) assert &#39;upper&#39; in dir(t) . class _C(GetAttr): def __init__(self): self.default = type(&#39;_D&#39;, (), {&#39;_under&#39;: 1, &#39;__dunder&#39;: 2})() t = _C() test_eq(t.default._under, 1) test_eq(t._under, 1) # _ prefix attr access is allowed on component assert &#39;_under&#39; in dir(t) test_eq(t.default.__dunder, 2) test_fail(lambda: t.__dunder) # __ prefix attr access is not allowed on component assert &#39;__dunder&#39; not in dir(t) assert t.__dir__ is not None # __ prefix attr access is allowed on composite assert &#39;__dir__&#39; in dir(t) . def delegate_attr(self, k, to): &quot;Use in `__getattr__` to delegate to attr `to` without inheriting from `GetAttr`&quot; if k.startswith(&#39;_&#39;) or k==to: raise AttributeError(k) try: return getattr(getattr(self,to), k) except AttributeError: raise AttributeError(k) from None class _C: f = &#39;Hi&#39; def __getattr__(self, k): return delegate_attr(self, k, &#39;f&#39;) t = _C() test_eq(t.lower(), &#39;hi&#39;) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/04/05/fastcore-foundations-1.html",
            "relUrl": "/fastcore/fastai/python/2020/04/05/fastcore-foundations-1.html",
            "date": " • Apr 5, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Roger Penrose",
            "content": ". A proof of a statement $p$, is a sequence of statements which follow logically from a set of axioms and ends with the statement $p$. For any given sequence ending in $p$, a computer could verify wether it constitutes a proof or not. . On november of 1931, Kurt Gödel, sent waves through the mathematical world by publishing On Formally Undecidable Propositions of Principia Mathematica and Related Systems. In this paper, Kurt shows that given any formal system, you can build a statement $q$ which you can see is true, but it cannot be proved within that system. i.e., thre is no formally verifiable sequence of statements within that system that ends with $q$. . What does it mean you can see in the paragraph above? . Warning: I haven&#8217;t studied the proof myself. . This you can see has to do with the meaning of symbols, and thus, with understanding (I know, equally foggie terms). For a machine it does not makes sense to think of it as true, unless the statement itself is appended to the formal system as an axiom. We humans, by the meaning attached to the symbols, can conceive of that statement as being true. . Roger wonders were this understanding comes from. In going through each physical theory, his argument is that (almost) all of them can be put into a computer 1. You can run black hole simulations on a computer and you can even put the Schrödinger equation in it. However, according to him 2, quantum mechanics is incomplete, especifically, because of the collapse of the wave function. This collapse is not in the equation. There is not sistemathic theory which characterizes what constitutes and observation and what doesn&#39;t. Roger believes this is where a tentative building block of consciousness might be found. . 1. A computer can obtain solutions, given enough time, with arbitrary precision. One might wonder if this closeness is close enough.↩ . 2. He also quotes authority here: Einstein, Schrödinger, and Dirac↩ .",
            "url": "https://juan-carlos-calvo.github.io/blog/podcast/physics/consciousness/philosophy/roger%20penrose/2020/04/04/roger-penrose-ai-podcast.html",
            "relUrl": "/podcast/physics/consciousness/philosophy/roger%20penrose/2020/04/04/roger-penrose-ai-podcast.html",
            "date": " • Apr 4, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Metaclasses",
            "content": "When we instantiate a class, we create an object with a memory location. . class Foo: pass o = Foo() print(o) . &lt;__main__.Foo object at 0x11a6b29b0&gt; . for example the above object is located at . hex(id(o)) . &#39;0x11aec27f0&#39; . similarly, when the above class was created, it also created an object with a memory location. Namely, . hex(id(Foo)) . &#39;0x7fb89764d9b8&#39; . What&#39;s more, just as we can find out the class of o, we can learn what&#39;s the class of Foo . o.__class__ . __main__.Foo . Foo.__class__ . type . that&#39;s right. The same built in method we use to find the type of objects. . Is type also an object? what&#39;s its class? . type.__class__ . type . type itself. So is not turttles all the way down. . When an object is created, its class calls __new__ which if it hasn´t been explicitly defined, it is inherited from its parent class. And, if the parent class hasn´t been explicitly defined, it is the class object. Thus, o is created by object.__new__ . o = object.__new__(Foo) . Just as o is created by the method __new__ of object . Foo is created by the method __new__ of type . Foo = type.__new__(type, &#39;Foo&#39;, (), {}) . or more simply . Foo = type(&#39;Foo&#39;, (), {}) . Since type allow us to create classes the same way a class allow us to create objects, type is called a metaclass. . In the tuple and dictionary above, we can pass base classes and attributes/methods respectively, that define the class. For example: . for . class Faa: pass . . Foo = type(&#39;Foo&#39;, (Faa, ), {&#39;attr&#39;: 100, &#39;attr_val&#39;: lambda x : x.attr}) . is equivalent to . class Foo(Faa): attr = 100 def attr_val(self): return self.attr . Now let&#39;s suppose we wanted to customize the creation of all classes so that all classes&#39;s methods get timed. One option would be to modify type.__new__ so that all methods in the dictionary argument get decorated with . import types import time from functools import wraps def timeit(f): @wraps(f) def wrapper(*args, **kwargs): start = time.time() resp = f(*args, **kwargs) end = time.time() return (resp, end - start) return wrapper . However, python doesn´t let us modify type&#39;s methods. Instead, it allow us to create a class inheriting from type (a metaclass), create our own __new__ method, . class TimeMeta(type): def __new__(cls, name, bases, attr):# Replace each function with a decorated version of the function for name, value in attr.items(): if type(value) is types.FunctionType or type(value) is types.MethodType: attr[name] = timeit(value) # Return a new type called TimeMeta return super().__new__(cls, name, bases, attr) . and then define classes using this new created metaclass. . class Animal(metaclass=TimeMeta): def talk(self): time.sleep(1) print(&quot;Animal talk&quot;) . a = Animal() . a.talk() . Animal talk . (None, 1.0045440196990967) . Also, all classes inheriting from classes thus created, will also have the same metaclass . class Cow(Animal): def talk(self): time.sleep(1) print(&quot;Moo&quot;) . print(Animal.__class__) . &lt;class &#39;__main__.TimeMeta&#39;&gt; . c = Cow() . c.talk() . Moo . (None, 1.005091667175293) . References . 1. Python: Meta-Programming↩ . 2. Great answer from StackOverflow↩ . 3. Python Metaclasses↩ .",
            "url": "https://juan-carlos-calvo.github.io/blog/python/2020/03/29/metaclasses.html",
            "relUrl": "/python/2020/03/29/metaclasses.html",
            "date": " • Mar 29, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Fastcore 00",
            "content": "This is the first of a series of posts Fastcore # whose aim is just for me to go through the development of the fastcore library to understand it. . from fastcore.imports import * . Test . Helper functions to quickly write tests in notebooks . Simple test functions . We can check that code raises an exception when that&#39;s expected (test_fail). To test for equality or inequality (with different types of things) we define a simple function test that compares two object with a given cmp operator. . def test_fail(f, msg=&#39;&#39;, contains=&#39;&#39;): &quot;Fails with `msg` unless `f()` raises an exception and (optionally) has `contains` in `e.args`&quot; try: f() except Exception as e: assert not contains or contains in str(e) return assert False,f&quot;Expected exception but none raised. {msg}&quot; . def _fail(): raise Exception(&quot;foobar&quot;) test_fail(_fail, contains=&quot;foo&quot;) def _fail(): raise Exception() test_fail(_fail) . def test(a, b, cmp,cname=None): &quot;`assert` that `cmp(a,b)`; display inputs and `cname or cmp.__name__` if it fails&quot; if cname is None: cname=cmp.__name__ assert cmp(a,b),f&quot;{cname}: n{a} n{b}&quot; . test([1,2],[1,2], operator.eq) test_fail(lambda: test([1,2],[1], operator.eq)) test([1,2],[1], operator.ne) test_fail(lambda: test([1,2],[1,2], operator.ne)) . test([&#39;abc&#39;], [&#39;abc&#39;], all_equal) . test([[&#39;abc&#39;],[&#39;a&#39;]], [[&#39;abc&#39;],[&#39;a&#39;]], equals) . def nequals(a,b): &quot;Compares `a` and `b` for `not equals`&quot; return not equals(a,b) . test([&#39;abc&#39;], [&#39;ab&#39; ], nequals) . test_eq test_ne, etc... . Just use test_eq/test_ne to test for ==/!=. test_eq_type check things are equals and of the same type. We define them using test: . def test_eq(a,b): &quot;`test` that `a==b`&quot; test(a,b,equals, &#39;==&#39;) . test_eq([1,2],[1,2]) test_eq([1,2],map(int,[1,2])) test_eq(array([1,2]),array([1,2])) test_eq(array([1,2]),array([1,2])) test_eq([array([1,2]),3],[array([1,2]),3]) test_eq(dict(a=1,b=2), dict(b=2,a=1)) test_fail(lambda: test_eq([1,2], 1), contains=&quot;==&quot;) test_eq({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}, {&#39;c&#39;, &#39;a&#39;, &#39;b&#39;}) . df1 = pd.DataFrame(dict(a=[1,2],b=[&#39;a&#39;,&#39;b&#39;])) df2 = pd.DataFrame(dict(a=[1,2],b=[&#39;a&#39;,&#39;b&#39;])) test_eq(df1,df2) test_eq(df1.a,df2.a) class T(pd.Series): pass test_eq(df1.iloc[0], T(df2.iloc[0])) . def test_eq_type(a,b): &quot;`test` that `a==b` and are same type&quot; test_eq(a,b) test_eq(type(a),type(b)) if isinstance(a,(list,tuple)): test_eq(map(type,a),map(type,b)) . test_eq_type(1,1) test_fail(lambda: test_eq_type(1,1.)) test_eq_type([1,1],[1,1]) test_fail(lambda: test_eq_type([1,1],(1,1))) test_fail(lambda: test_eq_type([1,1],[1,1.])) . def test_ne(a,b): &quot;`test` that `a!=b`&quot; test(a,b,nequals,&#39;!=&#39;) . test_ne([1,2],[1]) test_ne([1,2],[1,3]) test_ne(array([1,2]),array([1,1])) test_ne(array([1,2]),array([1,1])) test_ne([array([1,2]),3],[array([1,2])]) test_ne([3,4],array([3])) test_ne([3,4],array([3,5])) test_ne(dict(a=1,b=2), [&#39;a&#39;, &#39;b&#39;]) test_ne([&#39;a&#39;, &#39;b&#39;], dict(a=1,b=2)) . def is_close(a,b,eps=1e-5): &quot;Is `a` within `eps` of `b`&quot; if hasattr(a, &#39;__array__&#39;) or hasattr(b,&#39;__array__&#39;): return (abs(a-b)&lt;eps).all() if isinstance(a, (Iterable,Generator)) or isinstance(b, (Iterable,Generator)): return is_close(np.array(a), np.array(b), eps=eps) return abs(a-b)&lt;eps . def test_close(a,b,eps=1e-5): &quot;`test` that `a` is within `eps` of `b`&quot; test(a,b,partial(is_close,eps=eps),&#39;close&#39;) . test_close(1,1.001,eps=1e-2) test_fail(lambda: test_close(1,1.001)) test_close([-0.001,1.001], [0.,1.], eps=1e-2) test_close(np.array([-0.001,1.001]), np.array([0.,1.]), eps=1e-2) test_close(array([-0.001,1.001]), array([0.,1.]), eps=1e-2) . def test_is(a,b): &quot;`test` that `a is b`&quot; test(a,b,operator.is_, &#39;is&#39;) . test_fail(lambda: test_is([1], [1])) a = [1] test_is(a, a) . def test_shuffled(a,b): &quot;`test` that `a` and `b` are shuffled versions of the same sequence of items&quot; test_ne(a, b) test_eq(Counter(a), Counter(b)) . a = list(range(50)) b = copy(a) random.shuffle(b) test_shuffled(a,b) test_fail(lambda:test_shuffled(a,a)) . a = &#39;abc&#39; b = &#39;abcabc&#39; test_fail(lambda:test_shuffled(a,b)) . a = [&#39;a&#39;, 42, True] b = [42, True, &#39;a&#39;] test_shuffled(a,b) . def test_stdout(f, exp, regex=False): &quot;Test that `f` prints `exp` to stdout, optionally checking as `regex`&quot; s = io.StringIO() with redirect_stdout(s): f() if regex: assert re.search(exp, s.getvalue()) is not None else: test_eq(s.getvalue(), f&#39;{exp} n&#39; if len(exp) &gt; 0 else &#39;&#39;) . test_stdout(lambda: print(&#39;hi&#39;), &#39;hi&#39;) test_fail(lambda: test_stdout(lambda: print(&#39;hi&#39;), &#39;ho&#39;)) test_stdout(lambda: 1+1, &#39;&#39;) test_stdout(lambda: print(&#39;hi there!&#39;), r&#39;^hi.*!$&#39;, regex=True) . def test_warns(f, show=False): with warnings.catch_warnings(record=True) as w: f() test_ne(len(w), 0) if show: for e in w: print(f&quot;{e.category}: {e.message}&quot;) . test_warns(lambda: warnings.warn(&quot;Oh no!&quot;), {}) test_fail(lambda: test_warns(lambda: 2+2)) . test_warns(lambda: warnings.warn(&quot;Oh no!&quot;), show=True) . &lt;class &#39;UserWarning&#39;&gt;: Oh no! . TEST_IMAGE = &#39;my_icons/puppy.jpg&#39; . im = Image.open(TEST_IMAGE).resize((128,128)); im . TEST_IMAGE_BW = &#39;my_icons/mnist3.png&#39; . im = Image.open(TEST_IMAGE_BW).resize((128,128)); im . def test_fig_exists(ax): &quot;Test there is a figure displayed in `ax`&quot; assert ax and len(np.frombuffer(ax.figure.canvas.tostring_argb(), dtype=np.uint8)) . fig,ax = plt.subplots() ax.imshow(array(im)); . test_fig_exists(ax) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/03/28/test-fastcore.html",
            "relUrl": "/fastcore/fastai/python/2020/03/28/test-fastcore.html",
            "date": " • Mar 28, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Cool gifs",
            "content": ". . This is time lapse footage of neurons making new connection to other neurons, This is what your thoughts look like pic.twitter.com/sv1cttCGau . &mdash; Universal-Sci (@universal_sci) February 7, 2020 .",
            "url": "https://juan-carlos-calvo.github.io/blog/gifs/twitter/2020/03/26/cool-gifs-1.html",
            "relUrl": "/gifs/twitter/2020/03/26/cool-gifs-1.html",
            "date": " • Mar 26, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "masks4all",
            "content": "The Czech Republic went from zero mask usage to 100% in 10 days, and in the process they halted the growth of new covid-19 cases.How? They made their own! They didn&#39;t need government help; they did it themselves.It&#39;s time for #masks4all. See why:https://t.co/SiYApRvByq1/ . &mdash; jeremyphoward (@jeremyphoward) March 25, 2020 .",
            "url": "https://juan-carlos-calvo.github.io/blog/twitter/2020/03/25/masks4all.html",
            "relUrl": "/twitter/2020/03/25/masks4all.html",
            "date": " • Mar 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Chilean Data Scientist. Views are mine. .",
          "url": "https://juan-carlos-calvo.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}