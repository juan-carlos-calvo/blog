{
  
    
        "post0": {
            "title": "Fastcore 01",
            "content": "from fastcore.imports import * . Core . Basic functions used in the fastai library . defaults = SimpleNamespace() . Metaclasses . See this blog post for more information about metaclasses. . PrePostInitMeta ensures that the classes defined with it run __pre_init__ and __post_init__ (without having to write self.__pre_init__() and self.__post_init__() in the actual init | NewChkMeta gives the PrePostInitMeta functionality and ensures classes defined with it don&#39;t re-create an object of their type whenever it&#39;s passed to the constructor | BypassNewMeta ensures classes defined with it can easily be casted form objects they subclass. | . class FixSigMeta(type): &quot;A metaclass that fixes the signature on classes that override __init__&quot; def __new__(cls, name, bases, dict): res = super().__new__(cls, name, bases, dict) if res.__init__ is not object.__init__: res.__signature__ = inspect.signature(res.__init__) return res . class PrePostInitMeta(FixSigMeta): &quot;A metaclass that calls optional `__pre_init__` and `__post_init__` methods&quot; def __call__(cls, *args, **kwargs): res = cls.__new__(cls) if type(res)==cls: if hasattr(res,&#39;__pre_init__&#39;): res.__pre_init__(*args,**kwargs) res.__init__(*args,**kwargs) if hasattr(res,&#39;__post_init__&#39;): res.__post_init__(*args,**kwargs) return res . class _T(metaclass=PrePostInitMeta): def __pre_init__(self): self.a = 0; assert self.a==0 def __init__(self,b=0): self.a += 1; assert self.a==1 def __post_init__(self): self.a += 1; assert self.a==2 t = _T() test_eq(t.a, 2) . class NewChkMeta(FixSigMeta): &quot;Metaclass to avoid recreating object passed to constructor&quot; def __call__(cls, x=None, *args, **kwargs): if not args and not kwargs and x is not None and isinstance(x,cls): x._newchk = 1 return x res = super().__call__(*((x,) + args), **kwargs) res._newchk = 0 return res . id(2) . 4557526112 . class F: pass . class GreatestMetaclass(type): def __new__(metacls, name, bases, attrs): x = super().__new__(metacls, name, bases, attrs) print(metacls) return x . class F(metaclass=GreatestMetaclass): pass . &lt;class &#39;__main__.GreatestMetaclass&#39;&gt; .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/05/28/fastcore-foundations-1.html",
            "relUrl": "/fastcore/fastai/python/2020/05/28/fastcore-foundations-1.html",
            "date": " • May 28, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Metaclasses",
            "content": "When we instantiate a class, we create an object with a memory location. . class Foo: pass o = Foo() print(o) . &lt;__main__.Foo object at 0x11a6b29b0&gt; . for example the above object is located at . hex(id(o)) . &#39;0x11aec27f0&#39; . similarly, when the above class was created, it also created an object with a memory location. Namely, . hex(id(Foo)) . &#39;0x7fb89764d9b8&#39; . What&#39;s more, just as we can find out the class of o, we can learn what&#39;s the class of Foo . o.__class__ . __main__.Foo . Foo.__class__ . type . that&#39;s right. The same built in method we use to find the type of objects. . Is type also an object? what&#39;s its class? . type.__class__ . type . type itself. So is not turttles all the way down. . When an object is created, its class calls __new__ which if it hasn´t been explicitly defined, it is inherited from its parent class. And, if the parent class hasn´t been explicitly defined, it is the class object. Thus, o is created by object.__new__ . o = object.__new__(Foo) . Just as o is created by the method __new__ of object . Foo is created by the method __new__ of type . Foo = type.__new__(type, &#39;Foo&#39;, (), {}) . or more simply . Foo = type(&#39;Foo&#39;, (), {}) . Since type allow us to create classes the same way a class allow us to create objects, type is called a metaclass. . In the tuple and dictionary above, we can pass base classes and attributes/methods respectively, that define the class. For example: . for . class Faa: pass . . Foo = type(&#39;Foo&#39;, (Faa, ), {&#39;attr&#39;: 100, &#39;attr_val&#39;: lambda x : x.attr}) . is equivalent to . class Foo(Faa): attr = 100 def attr_val(self): return self.attr . Now let&#39;s suppose we wanted to customize the creation of all classes so that all classes&#39;s methods get timed. One option would be to modify type.__new__ so that all methods in the dictionary argument get decorated with . import types import time from functools import wraps def timeit(f): @wraps(f) def wrapper(*args, **kwargs): start = time.time() resp = f(*args, **kwargs) end = time.time() return (resp, end - start) return wrapper . However, python doesn´t let us modify type&#39;s methods. Instead, it allow us to create a class inheriting from type (a metaclass), create our own __new__ method, . class TimeMeta(type): def __new__(cls, name, bases, attr):# Replace each function with a decorated version of the function for name, value in attr.items(): if type(value) is types.FunctionType or type(value) is types.MethodType: attr[name] = timeit(value) # Return a new type called TimeMeta return super().__new__(cls, name, bases, attr) . and then define classes using this new created metaclass. . class Animal(metaclass=TimeMeta): def talk(self): time.sleep(1) print(&quot;Animal talk&quot;) . a = Animal() . a.talk() . Animal talk . (None, 1.0045440196990967) . Also, all classes inheriting from classes thus created, will also have the same metaclass . class Cow(Animal): def talk(self): time.sleep(1) print(&quot;Moo&quot;) . print(Animal.__class__) . &lt;class &#39;__main__.TimeMeta&#39;&gt; . c = Cow() . c.talk() . Moo . (None, 1.005091667175293) . References . 1. Python: Meta-Programming↩ . 2. Great answer from StackOverflow↩ . 3. Python Metaclasses↩ .",
            "url": "https://juan-carlos-calvo.github.io/blog/python/2020/03/29/metaclasses.html",
            "relUrl": "/python/2020/03/29/metaclasses.html",
            "date": " • Mar 29, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastcore 00",
            "content": "This is the first of a series of posts Fastcore # whose aim is just for me to go through the development of the fastcore library to understand it. . from fastcore.imports import * . Test . Helper functions to quickly write tests in notebooks . Simple test functions . We can check that code raises an exception when that&#39;s expected (test_fail). To test for equality or inequality (with different types of things) we define a simple function test that compares two object with a given cmp operator. . def test_fail(f, msg=&#39;&#39;, contains=&#39;&#39;): &quot;Fails with `msg` unless `f()` raises an exception and (optionally) has `contains` in `e.args`&quot; try: f() except Exception as e: assert not contains or contains in str(e) return assert False,f&quot;Expected exception but none raised. {msg}&quot; . def _fail(): raise Exception(&quot;foobar&quot;) test_fail(_fail, contains=&quot;foo&quot;) def _fail(): raise Exception() test_fail(_fail) . def test(a, b, cmp,cname=None): &quot;`assert` that `cmp(a,b)`; display inputs and `cname or cmp.__name__` if it fails&quot; if cname is None: cname=cmp.__name__ assert cmp(a,b),f&quot;{cname}: n{a} n{b}&quot; . test([1,2],[1,2], operator.eq) test_fail(lambda: test([1,2],[1], operator.eq)) test([1,2],[1], operator.ne) test_fail(lambda: test([1,2],[1,2], operator.ne)) . test([&#39;abc&#39;], [&#39;abc&#39;], all_equal) . test([[&#39;abc&#39;],[&#39;a&#39;]], [[&#39;abc&#39;],[&#39;a&#39;]], equals) . def nequals(a,b): &quot;Compares `a` and `b` for `not equals`&quot; return not equals(a,b) . test([&#39;abc&#39;], [&#39;ab&#39; ], nequals) . test_eq test_ne, etc... . Just use test_eq/test_ne to test for ==/!=. test_eq_type check things are equals and of the same type. We define them using test: . def test_eq(a,b): &quot;`test` that `a==b`&quot; test(a,b,equals, &#39;==&#39;) . test_eq([1,2],[1,2]) test_eq([1,2],map(int,[1,2])) test_eq(array([1,2]),array([1,2])) test_eq(array([1,2]),array([1,2])) test_eq([array([1,2]),3],[array([1,2]),3]) test_eq(dict(a=1,b=2), dict(b=2,a=1)) test_fail(lambda: test_eq([1,2], 1), contains=&quot;==&quot;) test_eq({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}, {&#39;c&#39;, &#39;a&#39;, &#39;b&#39;}) . df1 = pd.DataFrame(dict(a=[1,2],b=[&#39;a&#39;,&#39;b&#39;])) df2 = pd.DataFrame(dict(a=[1,2],b=[&#39;a&#39;,&#39;b&#39;])) test_eq(df1,df2) test_eq(df1.a,df2.a) class T(pd.Series): pass test_eq(df1.iloc[0], T(df2.iloc[0])) . def test_eq_type(a,b): &quot;`test` that `a==b` and are same type&quot; test_eq(a,b) test_eq(type(a),type(b)) if isinstance(a,(list,tuple)): test_eq(map(type,a),map(type,b)) . test_eq_type(1,1) test_fail(lambda: test_eq_type(1,1.)) test_eq_type([1,1],[1,1]) test_fail(lambda: test_eq_type([1,1],(1,1))) test_fail(lambda: test_eq_type([1,1],[1,1.])) . def test_ne(a,b): &quot;`test` that `a!=b`&quot; test(a,b,nequals,&#39;!=&#39;) . test_ne([1,2],[1]) test_ne([1,2],[1,3]) test_ne(array([1,2]),array([1,1])) test_ne(array([1,2]),array([1,1])) test_ne([array([1,2]),3],[array([1,2])]) test_ne([3,4],array([3])) test_ne([3,4],array([3,5])) test_ne(dict(a=1,b=2), [&#39;a&#39;, &#39;b&#39;]) test_ne([&#39;a&#39;, &#39;b&#39;], dict(a=1,b=2)) . def is_close(a,b,eps=1e-5): &quot;Is `a` within `eps` of `b`&quot; if hasattr(a, &#39;__array__&#39;) or hasattr(b,&#39;__array__&#39;): return (abs(a-b)&lt;eps).all() if isinstance(a, (Iterable,Generator)) or isinstance(b, (Iterable,Generator)): return is_close(np.array(a), np.array(b), eps=eps) return abs(a-b)&lt;eps . def test_close(a,b,eps=1e-5): &quot;`test` that `a` is within `eps` of `b`&quot; test(a,b,partial(is_close,eps=eps),&#39;close&#39;) . test_close(1,1.001,eps=1e-2) test_fail(lambda: test_close(1,1.001)) test_close([-0.001,1.001], [0.,1.], eps=1e-2) test_close(np.array([-0.001,1.001]), np.array([0.,1.]), eps=1e-2) test_close(array([-0.001,1.001]), array([0.,1.]), eps=1e-2) . def test_is(a,b): &quot;`test` that `a is b`&quot; test(a,b,operator.is_, &#39;is&#39;) . test_fail(lambda: test_is([1], [1])) a = [1] test_is(a, a) . def test_shuffled(a,b): &quot;`test` that `a` and `b` are shuffled versions of the same sequence of items&quot; test_ne(a, b) test_eq(Counter(a), Counter(b)) . a = list(range(50)) b = copy(a) random.shuffle(b) test_shuffled(a,b) test_fail(lambda:test_shuffled(a,a)) . a = &#39;abc&#39; b = &#39;abcabc&#39; test_fail(lambda:test_shuffled(a,b)) . a = [&#39;a&#39;, 42, True] b = [42, True, &#39;a&#39;] test_shuffled(a,b) . def test_stdout(f, exp, regex=False): &quot;Test that `f` prints `exp` to stdout, optionally checking as `regex`&quot; s = io.StringIO() with redirect_stdout(s): f() if regex: assert re.search(exp, s.getvalue()) is not None else: test_eq(s.getvalue(), f&#39;{exp} n&#39; if len(exp) &gt; 0 else &#39;&#39;) . test_stdout(lambda: print(&#39;hi&#39;), &#39;hi&#39;) test_fail(lambda: test_stdout(lambda: print(&#39;hi&#39;), &#39;ho&#39;)) test_stdout(lambda: 1+1, &#39;&#39;) test_stdout(lambda: print(&#39;hi there!&#39;), r&#39;^hi.*!$&#39;, regex=True) . def test_warns(f, show=False): with warnings.catch_warnings(record=True) as w: f() test_ne(len(w), 0) if show: for e in w: print(f&quot;{e.category}: {e.message}&quot;) . test_warns(lambda: warnings.warn(&quot;Oh no!&quot;), {}) test_fail(lambda: test_warns(lambda: 2+2)) . test_warns(lambda: warnings.warn(&quot;Oh no!&quot;), show=True) . &lt;class &#39;UserWarning&#39;&gt;: Oh no! . TEST_IMAGE = &#39;my_icons/puppy.jpg&#39; . im = Image.open(TEST_IMAGE).resize((128,128)); im . TEST_IMAGE_BW = &#39;my_icons/mnist3.png&#39; . im = Image.open(TEST_IMAGE_BW).resize((128,128)); im . def test_fig_exists(ax): &quot;Test there is a figure displayed in `ax`&quot; assert ax and len(np.frombuffer(ax.figure.canvas.tostring_argb(), dtype=np.uint8)) . fig,ax = plt.subplots() ax.imshow(array(im)); . test_fig_exists(ax) .",
            "url": "https://juan-carlos-calvo.github.io/blog/fastcore/fastai/python/2020/03/28/test-fastcore.html",
            "relUrl": "/fastcore/fastai/python/2020/03/28/test-fastcore.html",
            "date": " • Mar 28, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Cool gifs",
            "content": ". . This is time lapse footage of neurons making new connection to other neurons, This is what your thoughts look like pic.twitter.com/sv1cttCGau . &mdash; Universal-Sci (@universal_sci) February 7, 2020 .",
            "url": "https://juan-carlos-calvo.github.io/blog/gifs/twitter/2020/03/26/cool-gifs-1.html",
            "relUrl": "/gifs/twitter/2020/03/26/cool-gifs-1.html",
            "date": " • Mar 26, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "masks4all",
            "content": "The Czech Republic went from zero mask usage to 100% in 10 days, and in the process they halted the growth of new covid-19 cases.How? They made their own! They didn&#39;t need government help; they did it themselves.It&#39;s time for #masks4all. See why:https://t.co/SiYApRvByq1/ . &mdash; Jeremy #masks4all Howard (@jeremyphoward) March 25, 2020 .",
            "url": "https://juan-carlos-calvo.github.io/blog/twitter/2020/03/25/masks4all.html",
            "relUrl": "/twitter/2020/03/25/masks4all.html",
            "date": " • Mar 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Chilean Data Scientist. Views are mine. .",
          "url": "https://juan-carlos-calvo.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}